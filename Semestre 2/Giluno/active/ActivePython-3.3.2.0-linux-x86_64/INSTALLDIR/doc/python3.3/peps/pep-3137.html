<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
  <title>PEP 3137 -- Immutable Bytes and Mutable Buffer</title>
  <link rel="stylesheet" href="pep.css" type="text/css" /></head>
<body bgcolor="white">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3137</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Immutable Bytes and Mutable Buffer</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">60304</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-3137.txt">2008-01-25 18:38:33 -0800 (Fri, 25 Jan 2008)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum &lt;guido&#32;&#97;t&#32;python.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">26-Sep-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">26-Sep-2007, 30-Sep-2007</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#introduction" id="id2">Introduction</a></li>
<li><a class="reference internal" href="#advantages" id="id3">Advantages</a></li>
<li><a class="reference internal" href="#naming" id="id4">Naming</a><ul>
<li><a class="reference internal" href="#summary" id="id5">Summary</a></li>
</ul>
</li>
<li><a class="reference internal" href="#literal-notations" id="id6">Literal Notations</a></li>
<li><a class="reference internal" href="#functionality" id="id7">Functionality</a><ul>
<li><a class="reference internal" href="#pep-3118-buffer-api" id="id8">PEP 3118 Buffer API</a></li>
<li><a class="reference internal" href="#constructors" id="id9">Constructors</a></li>
<li><a class="reference internal" href="#comparisons" id="id10">Comparisons</a></li>
<li><a class="reference internal" href="#slicing" id="id11">Slicing</a></li>
<li><a class="reference internal" href="#indexing" id="id12">Indexing</a></li>
<li><a class="reference internal" href="#str-and-repr" id="id13">Str() and Repr()</a></li>
<li><a class="reference internal" href="#operators" id="id14">Operators</a></li>
<li><a class="reference internal" href="#methods" id="id15">Methods</a></li>
<li><a class="reference internal" href="#bytes-and-the-str-type" id="id16">Bytes and the Str Type</a></li>
<li><a class="reference internal" href="#the-basestring-type" id="id17">The <tt class="docutils literal"><span class="pre">basestring</span></tt> Type</a></li>
<li><a class="reference internal" href="#pickling" id="id18">Pickling</a></li>
</ul>
</li>
<li><a class="reference internal" href="#copyright" id="id19">Copyright</a></li>
</ul>
</div>
<div class="section" id="introduction">
<h1><a class="toc-backref" href="#id2">Introduction</a></h1>
<p>After releasing Python 3.0a1 with a mutable bytes type, pressure
mounted to add a way to represent immutable bytes.  Gregory P. Smith
proposed a patch that would allow making a bytes object temporarily
immutable by requesting that the data be locked using the new buffer
API from <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a>.  This did not seem the right approach to me.</p>
<p>Jeffrey Yasskin, with the help of Adam Hupp, then prepared a patch to
make the bytes type immutable (by crudely removing all mutating APIs)
and fix the fall-out in the test suite.  This showed that there aren't
all that many places that depend on the mutability of bytes, with the
exception of code that builds up a return value from small pieces.</p>
<p>Thinking through the consequences, and noticing that using the array
module as an ersatz mutable bytes type is far from ideal, and
recalling a proposal put forward earlier by Talin, I floated the
suggestion to have both a mutable and an immutable bytes type.  (This
had been brought up before, but until seeing the evidence of Jeffrey's
patch I wasn't open to the suggestion.)</p>
<p>Moreover, a possible implementation strategy became clear: use the old
PyString implementation, stripped down to remove locale support and
implicit conversions to/from Unicode, for the immutable bytes type,
and keep the new PyBytes implementation as the mutable bytes type.</p>
<p>The ensuing discussion made it clear that the idea is welcome but
needs to be specified more precisely.  Hence this PEP.</p>
</div>
<div class="section" id="advantages">
<h1><a class="toc-backref" href="#id3">Advantages</a></h1>
<p>One advantage of having an immutable bytes type is that code objects
can use these.  It also makes it possible to efficiently create hash
tables using bytes for keys; this may be useful when parsing protocols
like HTTP or SMTP which are based on bytes representing text.</p>
<p>Porting code that manipulates binary data (or encoded text) in Python
2.x will be easier using the new design than using the original 3.0
design with mutable bytes; simply replace <tt class="docutils literal"><span class="pre">str</span></tt> with <tt class="docutils literal"><span class="pre">bytes</span></tt> and
change '...' literals into b'...' literals.</p>
</div>
<div class="section" id="naming">
<h1><a class="toc-backref" href="#id4">Naming</a></h1>
<p>I propose the following type names at the Python level:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bytes</span></tt> is an immutable array of bytes (PyString)</li>
<li><tt class="docutils literal"><span class="pre">bytearray</span></tt> is a mutable array of bytes (PyBytes)</li>
<li><tt class="docutils literal"><span class="pre">memoryview</span></tt> is a bytes view on another object (PyMemory)</li>
</ul>
</blockquote>
<p>The old type named <tt class="docutils literal"><span class="pre">buffer</span></tt> is so similar to the new type
<tt class="docutils literal"><span class="pre">memoryview</span></tt>, introduce by <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a>, that it is redundant.  The rest
of this PEP doesn't discuss the functionality of <tt class="docutils literal"><span class="pre">memoryview</span></tt>; it is
just mentioned here to justify getting rid of the old <tt class="docutils literal"><span class="pre">buffer</span></tt> type.
(An earlier version of this PEP proposed <tt class="docutils literal"><span class="pre">buffer</span></tt> as the new name
for PyBytes; in the end this name was deemed to confusing given the
many other uses of the word buffer.)</p>
<p>While eventually it makes sense to change the C API names, this PEP
maintains the old C API names, which should be familiar to all.</p>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id5">Summary</a></h2>
<p>Here's a simple ASCII-art table summarizing the type names in various
Python versions:</p>
<pre class="literal-block">
+--------------+-------------+------------+--------------------------+
| C name       | 2.x    repr | 3.0a1 repr | 3.0a2               repr |
+--------------+-------------+------------+--------------------------+
| PyUnicode    | unicode u'' | str     '' | str                   '' |
| PyString     | str      '' | str8   s'' | bytes                b'' |
| PyBytes      | N/A         | bytes  b'' | bytearray bytearray(b'') |
| PyBuffer     | buffer      | buffer     | N/A                      |
| PyMemoryView | N/A         | memoryview | memoryview         &lt;...&gt; |
+--------------+-------------+------------+--------------------------+
</pre>
</div>
</div>
<div class="section" id="literal-notations">
<h1><a class="toc-backref" href="#id6">Literal Notations</a></h1>
<p>The b'...' notation introduced in Python 3.0a1 returns an immutable
bytes object, whatever variation is used.  To create a mutable array
of bytes, use bytearray(b'...') or bytearray([...]).  The latter form
takes a list of integers in range(256).</p>
</div>
<div class="section" id="functionality">
<h1><a class="toc-backref" href="#id7">Functionality</a></h1>
<div class="section" id="pep-3118-buffer-api">
<h2><a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> Buffer API</h2>
<p>Both bytes and bytearray implement the <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> buffer API.  The bytes
type only implements read-only requests; the bytearray type allows
writable and data-locked requests as well.  The element data type is
always 'B' (i.e. unsigned byte).</p>
</div>
<div class="section" id="constructors">
<h2><a class="toc-backref" href="#id9">Constructors</a></h2>
<p>There are four forms of constructors, applicable to both bytes and
bytearray:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bytes(&lt;bytes&gt;)</span></tt>, <tt class="docutils literal"><span class="pre">bytes(&lt;bytearray&gt;)</span></tt>, <tt class="docutils literal"><span class="pre">bytearray(&lt;bytes&gt;)</span></tt>,
<tt class="docutils literal"><span class="pre">bytearray(&lt;bytearray&gt;)</span></tt>: simple copying constructors, with the
note that <tt class="docutils literal"><span class="pre">bytes(&lt;bytes&gt;)</span></tt> might return its (immutable)
argument, but <tt class="docutils literal"><span class="pre">bytearray(&lt;bytearray&gt;)</span></tt> always makes a copy.</li>
<li><tt class="docutils literal"><span class="pre">bytes(&lt;str&gt;,</span> <span class="pre">&lt;encoding&gt;[,</span> <span class="pre">&lt;errors&gt;])</span></tt>, <tt class="docutils literal"><span class="pre">bytearray(&lt;str&gt;,</span>
<span class="pre">&lt;encoding&gt;[,</span> <span class="pre">&lt;errors&gt;])</span></tt>: encode a text string.  Note that the
<tt class="docutils literal"><span class="pre">str.encode()</span></tt> method returns an <em>immutable</em> bytes object.  The
&lt;encoding&gt; argument is mandatory; &lt;errors&gt; is optional.
&lt;encoding&gt; and &lt;errrors&gt;, if given, must be <tt class="docutils literal"><span class="pre">str</span></tt> instances.</li>
<li><tt class="docutils literal"><span class="pre">bytes(&lt;memory</span> <span class="pre">view&gt;)</span></tt>, <tt class="docutils literal"><span class="pre">bytearray(&lt;memory</span> <span class="pre">view&gt;)</span></tt>: construct
a bytes or bytearray object from anything that implements the <a class="reference external" href="/dev/peps/pep-3118">PEP
3118</a> buffer API.</li>
<li><tt class="docutils literal"><span class="pre">bytes(&lt;iterable</span> <span class="pre">of</span> <span class="pre">ints&gt;)</span></tt>, <tt class="docutils literal"><span class="pre">bytearray(&lt;iterable</span> <span class="pre">of</span> <span class="pre">ints&gt;)</span></tt>:
construct a bytes or bytearray object from a stream of integers in
range(256).</li>
<li><tt class="docutils literal"><span class="pre">bytes(&lt;int&gt;)</span></tt>, <tt class="docutils literal"><span class="pre">bytearray(&lt;int&gt;)</span></tt>: construct a
zero-initialized bytes or bytearray object of a given length.</li>
</ul>
</blockquote>
</div>
<div class="section" id="comparisons">
<h2><a class="toc-backref" href="#id10">Comparisons</a></h2>
<p>The bytes and bytearray types are comparable with each other and
orderable, so that e.g. b'abc' == bytearray(b'abc') &lt; b'abd'.</p>
<p>Comparing either type to a str object for equality returns False
regardless of the contents of either operand.  Ordering comparisons
with str raise TypeError.  This is all conformant to the standard
rules for comparison and ordering between objects of incompatible
types.</p>
<p>(<strong>Note:</strong> in Python 3.0a1, comparing a bytes instance with a str
instance would raise TypeError, on the premise that this would catch
the occasional mistake quicker, especially in code ported from Python
2.x.  However, a long discussion on the python-3000 list pointed out
so many problems with this that it is clearly a bad idea, to be rolled
back in 3.0a2 regardless of the fate of the rest of this PEP.)</p>
</div>
<div class="section" id="slicing">
<h2><a class="toc-backref" href="#id11">Slicing</a></h2>
<p>Slicing a bytes object returns a bytes object.  Slicing a bytearray
object returns a bytearray object.</p>
<p>Slice assignment to a bytearray object accepts anything that
implements the <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> buffer API, or an iterable of integers in
range(256).</p>
</div>
<div class="section" id="indexing">
<h2><a class="toc-backref" href="#id12">Indexing</a></h2>
<p>Indexing bytes and bytearray returns small ints (like the bytes type in
3.0a1, and like lists or array.array('B')).</p>
<p>Assignment to an item of a bytearray object accepts an int in
range(256).  (To assign from a bytes sequence, use a slice
assignment.)</p>
</div>
<div class="section" id="str-and-repr">
<h2><a class="toc-backref" href="#id13">Str() and Repr()</a></h2>
<p>The str() and repr() functions return the same thing for these
objects.  The repr() of a bytes object returns a b'...' style literal.
The repr() of a bytearray returns a string of the form &quot;bytearray(b'...')&quot;.</p>
</div>
<div class="section" id="operators">
<h2><a class="toc-backref" href="#id14">Operators</a></h2>
<p>The following operators are implemented by the bytes and bytearray
types, except where mentioned:</p>
<blockquote>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">b1</span> <span class="pre">+</span> <span class="pre">b2</span></tt>: concatenation.  With mixed bytes/bytearray operands,
the return type is that of the first argument (this seems arbitrary
until you consider how <tt class="docutils literal"><span class="pre">+=</span></tt> works).</li>
<li><tt class="docutils literal"><span class="pre">b1</span> <span class="pre">+=</span> <span class="pre">b2</span></tt>: mutates b1 if it is a bytearray object.</li>
<li><tt class="docutils literal"><span class="pre">b</span> <span class="pre">*</span> <span class="pre">n</span></tt>, <tt class="docutils literal"><span class="pre">n</span> <span class="pre">*</span> <span class="pre">b</span></tt>: repetition; n must be an integer.</li>
<li><tt class="docutils literal"><span class="pre">b</span> <span class="pre">*=</span> <span class="pre">n</span></tt>: mutates b if it is a bytearray object.</li>
<li><tt class="docutils literal"><span class="pre">b1</span> <span class="pre">in</span> <span class="pre">b2</span></tt>, <tt class="docutils literal"><span class="pre">b1</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b2</span></tt>: substring test; b1 can be any
object implementing the <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> buffer API.</li>
<li><tt class="docutils literal"><span class="pre">i</span> <span class="pre">in</span> <span class="pre">b</span></tt>, <tt class="docutils literal"><span class="pre">i</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">b</span></tt>: single-byte membership test; i must
be an integer (if it is a length-1 bytes array, it is considered
to be a substring test, with the same outcome).</li>
<li><tt class="docutils literal"><span class="pre">len(b)</span></tt>: the number of bytes.</li>
<li><tt class="docutils literal"><span class="pre">hash(b)</span></tt>: the hash value; only implemented by the bytes type.</li>
</ul>
</blockquote>
<p>Note that the % operator is <em>not</em> implemented.  It does not appear
worth the complexity.</p>
</div>
<div class="section" id="methods">
<h2><a class="toc-backref" href="#id15">Methods</a></h2>
<p>The following methods are implemented by bytes as well as bytearray, with
similar semantics.  They accept anything that implements the <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a>
buffer API for bytes arguments, and return the same type as the object
whose method is called (&quot;self&quot;):</p>
<pre class="literal-block">
.capitalize(), .center(), .count(), .decode(), .endswith(),
.expandtabs(), .find(), .index(), .isalnum(), .isalpha(), .isdigit(),
.islower(), .isspace(), .istitle(), .isupper(), .join(), .ljust(),
.lower(), .lstrip(), .partition(), .replace(), .rfind(), .rindex(),
.rjust(), .rpartition(), .rsplit(), .rstrip(), .split(),
.splitlines(), .startswith(), .strip(), .swapcase(), .title(),
.translate(), .upper(), .zfill()
</pre>
<p>This is exactly the set of methods present on the str type in Python
2.x, with the exclusion of .encode().  The signatures and semantics
are the same too.  However, whenever character classes like letter,
whitespace, lower case are used, the ASCII definitions of these
classes are used.  (The Python 2.x str type uses the definitions from
the current locale, settable through the locale module.)  The
.encode() method is left out because of the more strict definitions of
encoding and decoding in Python 3000: encoding always takes a Unicode
string and returns a bytes sequence, and decoding always takes a bytes
sequence and returns a Unicode string.</p>
<p>In addition, both types implement the class method <tt class="docutils literal"><span class="pre">.fromhex()</span></tt>,
which constructs an object from a string containing hexadecimal values
(with or without spaces between the bytes).</p>
<p>The bytearray type implements these additional methods from the
MutableSequence ABC (see <a class="reference external" href="/dev/peps/pep-3119">PEP 3119</a>):</p>
<blockquote>
.extend(), .insert(), .append(), .reverse(), .pop(), .remove().</blockquote>
</div>
<div class="section" id="bytes-and-the-str-type">
<h2><a class="toc-backref" href="#id16">Bytes and the Str Type</a></h2>
<p>Like the bytes type in Python 3.0a1, and unlike the relationship
between str and unicode in Python 2.x, attempts to mix bytes (or
bytearray) objects and str objects without specifying an encoding will
raise a TypeError exception.  (However, comparing bytes/bytearray and
str objects for equality will simply return False; see the section on
Comparisons above.)</p>
<p>Conversions between bytes or bytearray objects and str objects must
always be explicit, using an encoding.  There are two equivalent APIs:
<tt class="docutils literal"><span class="pre">str(b,</span> <span class="pre">&lt;encoding&gt;[,</span> <span class="pre">&lt;errors&gt;])</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">b.decode(&lt;encoding&gt;[,</span> <span class="pre">&lt;errors&gt;])</span></tt>, and
<tt class="docutils literal"><span class="pre">bytes(s,</span> <span class="pre">&lt;encoding&gt;[,</span> <span class="pre">&lt;errors&gt;])</span></tt> is equivalent to
<tt class="docutils literal"><span class="pre">s.encode(&lt;encoding&gt;[,</span> <span class="pre">&lt;errors&gt;])</span></tt>.</p>
<p>There is one exception: we can convert from bytes (or bytearray) to str
without specifying an encoding by writing <tt class="docutils literal"><span class="pre">str(b)</span></tt>.  This produces
the same result as <tt class="docutils literal"><span class="pre">repr(b)</span></tt>.  This exception is necessary because
of the general promise that <em>any</em> object can be printed, and printing
is just a special case of conversion to str.  There is however no
promise that printing a bytes object interprets the individual bytes
as characters (unlike in Python 2.x).</p>
<p>The str type currently implements the <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> buffer API.  While this
is perhaps occasionally convenient, it is also potentially confusing,
because the bytes accessed via the buffer API represent a
platform-depending encoding: depending on the platform byte order and
a compile-time configuration option, the encoding could be UTF-16-BE,
UTF-16-LE, UTF-32-BE, or UTF-32-LE.  Worse, a different implementation
of the str type might completely change the bytes representation,
e.g. to UTF-8, or even make it impossible to access the data as a
contiguous array of bytes at all.  Therefore, the <a class="reference external" href="/dev/peps/pep-3118">PEP 3118</a> buffer API
will be removed from the str type.</p>
</div>
<div class="section" id="the-basestring-type">
<h2><a class="toc-backref" href="#id17">The <tt class="docutils literal"><span class="pre">basestring</span></tt> Type</a></h2>
<p>The <tt class="docutils literal"><span class="pre">basestring</span></tt> type will be removed from the language.  Code that
used to say <tt class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">basestring)</span></tt> should be changed to use
<tt class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">str)</span></tt> instead.</p>
</div>
<div class="section" id="pickling">
<h2><a class="toc-backref" href="#id18">Pickling</a></h2>
<p>Left as an exercise for the reader.</p>
</div>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id19">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="pep-3137.txt">View document source</a>.
Generated on: 2013-09-17 06:14 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
