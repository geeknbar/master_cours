<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 244 -- The `directive' statement</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">

<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>244</td></tr>
  <tr><th>Title:&nbsp;</th><td>The `directive' statement</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision: 56117 $</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="http://svn.python.org/view/peps/trunk/pep-0244.txt">$Date: 2007-06-28 13:03:18 -0700 (Thu, 28 Jun 2007) $</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Martin von LÃ¶wis &lt;martin&#32;&#97;t&#32;v.loewis.de&gt;</td></tr>
  <tr><th>Status:&nbsp;</th><td>Rejected</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Created:&nbsp;</th><td>20-Mar-2001</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>2.1</td></tr>
  <tr><th>Post-History:&nbsp;</th><td></td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Motivation</h3>
<pre>
    From time to time, Python makes an incompatible change to the
    advertised semantics of core language constructs, or changes their
    accidental (implementation-dependent) behavior in some way.  While
    this is never done capriciously, and is always done with the aim
    of improving the language over the long term, over the short term
    it's contentious and disrupting.

    <a href="pep-0001.html">PEP 1</a>, Guidelines for Language Evolution[1] suggests ways to ease
    the pain, and this PEP introduces some machinery in support of
    that.

    <a href="pep-0002.html">PEP 2</a>, Statically Nested Scopes[2] is the first application, and
    will be used as an example here.

    When a new, potentially incompatible language feature is added,
    some modules and libraries may chose to use it, while others may
    not.  This specification introduces a syntax where a module author
    can denote whether a certain language feature is used in the
    module or not.

    In discussion of this PEP, readers commented that there are two
    kinds of "settable" language features:

    - those that are designed to eventually become the only option, at
      which time specifying use of them is not necessary anymore.  The
      features for which the syntax of the "Back to the __future__"
      <a href="pep-0236.html">PEP 236</a>, Back to the __future__[3] was proposed fall into this
      category.  This PEP supports declaring such features, and
      supports phasing out the "old" meaning of constructs whose
      semantics has changed under the new feature.  However, it
      defines no policy as to what features must be phased out
      eventually.

    - those which are designed to stay optional forever, e.g. if they
      change some default setting in the interpreter.  An example for
      such settings might be the request to always emit line-number
      instructions for a certain module; no specific flags of that
      kind are proposed in this specification.

    Since a primary goal of this PEP is to support new language
    constructs without immediately breaking old libraries, special
    care was taken not to break old libraries by introducing the new
    syntax.


</pre>
<h3>Syntax</h3>
<pre>
    A directive_statement is a statement of the form

        directive_statement: 'directive' NAME [atom] [';'] NEWLINE

    The name in the directive indicates the kind of the directive; it
    defines whether the optional atom can be present, and whether
    there are further syntactical or semantical restrictions to the
    atom.  In addition, depending on the name of the directive,
    certain additional syntactical or semantical restrictions may be
    placed on the directive (e.g. placement of the directive in the
    module may be restricted to the top of the module).

    In the directive_statement, 'directive' is a new
    keyword. According to [1], this keyword is initially considered as
    a keyword only when used in a directive statement, see "Backwards
    Compatibility" below.


</pre>
<h3>Semantics</h3>
<pre>
    A directive statement instructs the Python interpreter to process
    a source file in a different way; the specific details of that
    processing depend on the directive name.  The optional atom is
    typically interpreted when the source code is processed; details
    of that interpretation depend on the directive.


</pre>
<h3>Specific Directives: transitional</h3>
<pre>
    If a syntactical or semantical change is added to Python which is
    incompatible, [1] mandates a transitional evolution of the
    language, where the new feature is initially available alongside
    with the old one.  Such a transition is possible by means of the
    transitional directive.

    In a transitional directive, the NAME is 'transitional'. The atom
    MUST be present, and it MUST be a NAME.  The possible values for
    that name are defined when the language change is defined.  One
    example for such a directive is

        directive transitional nested_scopes

    The transitional directive MUST occur at before any other
    statement in a module, except for the documentation string
    (i.e. it may appear as the second statement of a module only if
    the first statement is a STRING+).


</pre>
<h3>Backwards Compatibility</h3>
<pre>
    Introducing 'directive' as a new keyword might cause
    incompatibilities with existing code.  Following the guideline in
    [1], in the initial implementation of this specification,
    directive is a new keyword only if it was used in a valid
    directive_statement (i.e. if it appeared as the first non-string
    token in a module).


</pre>
<h3>Unresolved Problems:  directive as the first identifier</h3>
<pre>
    Using directive in a module as

    directive = 1

    (i.e. the name directive appears as the first thing in a module)
    will treat it as keyword, not as identifier. It would be possible
    to classify it as a NAME with an additional look-ahead token, but
    such look-ahead is not available in the Python tokenizer.


</pre>
<h3>Questions and Answers</h3>
<pre>
    Q: It looks like this PEP was written to allow definition of source
       code character sets.  Is that true?

    A: No.  Even though the directive facility can be extended to
       allow source code encodings, no specific directive is proposed.

    Q: Then why was this PEP written at all?

    A: It acts as a counter-proposal to [3], which proposes to
       overload the import statement with a new meaning.  This PEP
       allows to solve the problem in a more general way.

    Q: But isn't mixing source encodings and language changes like
       mixing apples and oranges?

    A: Perhaps.  To address the difference, the predefined
       "transitional" directive has been defined.


</pre>
<h3>References and Footnotes</h3>
<pre>
    [1] <a href="pep-0005.html">PEP 5</a>, Guidelines for Language Evolution, Prescod
        <a href="http://www.python.org/peps/pep-0005.html">http://www.python.org/peps/pep-0005.html</a>

    [2] <a href="pep-0227.html">PEP 227</a>, Statically Nested Scopes, Hylton
        <a href="http://www.python.org/peps/pep-0227.html">http://www.python.org/peps/pep-0227.html</a>

    [3] <a href="pep-0236.html">PEP 236</a>, Back to the __future__, Peters
        <a href="http://www.python.org/peps/pep-0236.html">http://www.python.org/peps/pep-0236.html</a>


</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.


</pre>
</div>
</body>
</html>
