<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
  <title>PEP 3114 -- Renaming iterator.next() to iterator.__next__()</title>
  <link rel="stylesheet" href="pep.css" type="text/css" /></head>
<body bgcolor="white">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3114</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Renaming iterator.next() to iterator.__next__()</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">63925</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-3114.txt">2008-06-03 08:18:48 -0700 (Tue, 03 Jun 2008)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Ka-Ping Yee &lt;ping&#32;&#97;t&#32;zesty.ca&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Final</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">04-Mar-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id13">Abstract</a></li>
<li><a class="reference internal" href="#names-with-double-underscores" id="id14">Names With Double Underscores</a></li>
<li><a class="reference internal" href="#double-underscore-methods-and-built-in-functions" id="id15">Double-Underscore Methods and Built-In Functions</a></li>
<li><a class="reference internal" href="#previous-proposals" id="id16">Previous Proposals</a></li>
<li><a class="reference internal" href="#objections" id="id17">Objections</a></li>
<li><a class="reference internal" href="#transition-plan" id="id18">Transition Plan</a></li>
<li><a class="reference internal" href="#approval" id="id19">Approval</a></li>
<li><a class="reference internal" href="#implementation" id="id20">Implementation</a></li>
<li><a class="reference internal" href="#references" id="id21">References</a></li>
<li><a class="reference internal" href="#copyright" id="id22">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id13">Abstract</a></h1>
<p>The iterator protocol in Python 2.x consists of two methods:
<tt class="docutils literal"><span class="pre">__iter__()</span></tt> called on an iterable object to yield an iterator, and
<tt class="docutils literal"><span class="pre">next()</span></tt> called on an iterator object to yield the next item in the
sequence.  Using a <tt class="docutils literal"><span class="pre">for</span></tt> loop to iterate over an iterable object
implicitly calls both of these methods.  This PEP proposes that the
<tt class="docutils literal"><span class="pre">next</span></tt> method be renamed to <tt class="docutils literal"><span class="pre">__next__</span></tt>, consistent with all the
other protocols in Python in which a method is implicitly called as
part of a language-level protocol, and that a built-in function named
<tt class="docutils literal"><span class="pre">next</span></tt> be introduced to invoke <tt class="docutils literal"><span class="pre">__next__</span></tt> method, consistent with
the manner in which other protocols are explicitly invoked.</p>
</div>
<div class="section" id="names-with-double-underscores">
<h1><a class="toc-backref" href="#id14">Names With Double Underscores</a></h1>
<p>In Python, double underscores before and after a name are used to
distinguish names that belong to the language itself.  Attributes and
methods that are implicitly used or created by the interpreter employ
this naming convention; some examples are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">__file__</span></tt> - an attribute automatically created by the interpreter</li>
<li><tt class="docutils literal"><span class="pre">__dict__</span></tt> - an attribute with special meaning to the interpreter</li>
<li><tt class="docutils literal"><span class="pre">__init__</span></tt> - a method implicitly called by the interpreter</li>
</ul>
<p>Note that this convention applies to methods such as <tt class="docutils literal"><span class="pre">__init__</span></tt> that
are explicitly defined by the programmer, as well as attributes such as
<tt class="docutils literal"><span class="pre">__file__</span></tt> that can only be accessed by naming them explicitly, so it
includes names that are used <em>or</em> created by the interpreter.</p>
<p>(Not all things that are called &quot;protocols&quot; are made of methods with
double-underscore names.  For example, the <tt class="docutils literal"><span class="pre">__contains__</span></tt> method has
double underscores because the language construct <tt class="docutils literal"><span class="pre">x</span> <span class="pre">in</span> <span class="pre">y</span></tt> implicitly
calls <tt class="docutils literal"><span class="pre">__contains__</span></tt>.  But even though the <tt class="docutils literal"><span class="pre">read</span></tt> method is part of
the file protocol, it does not have double underscores because there is
no language construct that implicitly invokes <tt class="docutils literal"><span class="pre">x.read()</span></tt>.)</p>
<p>The use of double underscores creates a separate namespace for names
that are part of the Python language definition, so that programmers
are free to create variables, attributes, and methods that start with
letters, without fear of silently colliding with names that have a
language-defined purpose.  (Colliding with reserved keywords is still
a concern, but at least this will immediately yield a syntax error.)</p>
<p>The naming of the <tt class="docutils literal"><span class="pre">next</span></tt> method on iterators is an exception to
this convention.  Code that nowhere contains an explicit call to a
<tt class="docutils literal"><span class="pre">next</span></tt> method can nonetheless be silently affected by the presence
of such a method.  Therefore, this PEP proposes that iterators should
have a <tt class="docutils literal"><span class="pre">__next__</span></tt> method instead of a <tt class="docutils literal"><span class="pre">next</span></tt> method (with no
change in semantics).</p>
</div>
<div class="section" id="double-underscore-methods-and-built-in-functions">
<h1><a class="toc-backref" href="#id15">Double-Underscore Methods and Built-In Functions</a></h1>
<p>The Python language defines several protocols that are implemented or
customized by defining methods with double-underscore names.  In each
case, the protocol is provided by an internal method implemented as a
C function in the interpreter.  For objects defined in Python, this
C function supports customization by implicitly invoking a Python method
with a double-underscore name (it often does a little bit of additional
work beyond just calling the Python method.)</p>
<p>Sometimes the protocol is invoked by a syntactic construct:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">x[y]</span></tt> --&gt; internal <tt class="docutils literal"><span class="pre">tp_getitem</span></tt> --&gt; <tt class="docutils literal"><span class="pre">x.__getitem__(y)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">x</span> <span class="pre">+</span> <span class="pre">y</span></tt> --&gt; internal <tt class="docutils literal"><span class="pre">nb_add</span></tt> --&gt; <tt class="docutils literal"><span class="pre">x.__add__(y)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">-x</span></tt> --&gt; internal <tt class="docutils literal"><span class="pre">nb_negative</span></tt> --&gt; <tt class="docutils literal"><span class="pre">x.__neg__()</span></tt></li>
</ul>
<p>Sometimes there is no syntactic construct, but it is still useful to be
able to explicitly invoke the protocol.  For such cases Python offers a
built-in function of the same name but without the double underscores.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">len(x)</span></tt> --&gt; internal <tt class="docutils literal"><span class="pre">sq_length</span></tt> --&gt; <tt class="docutils literal"><span class="pre">x.__len__()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">hash(x)</span></tt> --&gt; internal <tt class="docutils literal"><span class="pre">tp_hash</span></tt> --&gt; <tt class="docutils literal"><span class="pre">x.__hash__()</span></tt></li>
<li><tt class="docutils literal"><span class="pre">iter(x)</span></tt> --&gt; internal <tt class="docutils literal"><span class="pre">tp_iter</span></tt> --&gt; <tt class="docutils literal"><span class="pre">x.__iter__()</span></tt></li>
</ul>
<p>Following this pattern, the natural way to handle <tt class="docutils literal"><span class="pre">next</span></tt> is to add a
<tt class="docutils literal"><span class="pre">next</span></tt> built-in function that behaves in exactly the same fashion.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">next(x)</span></tt> --&gt; internal <tt class="docutils literal"><span class="pre">tp_iternext</span></tt> --&gt; <tt class="docutils literal"><span class="pre">x.__next__()</span></tt></li>
</ul>
<p>Further, it is proposed that the <tt class="docutils literal"><span class="pre">next</span></tt> built-in function accept a
sentinel value as an optional second argument, following the style of
the <tt class="docutils literal"><span class="pre">getattr</span></tt> and <tt class="docutils literal"><span class="pre">iter</span></tt> built-in functions.  When called with two
arguments, <tt class="docutils literal"><span class="pre">next</span></tt> catches the StopIteration exception and returns
the sentinel value instead of propagating the exception.  This creates
a nice duality between <tt class="docutils literal"><span class="pre">iter</span></tt> and <tt class="docutils literal"><span class="pre">next</span></tt>:</p>
<blockquote>
iter(function, sentinel) &lt;--&gt; next(iterator, sentinel)</blockquote>
</div>
<div class="section" id="previous-proposals">
<h1><a class="toc-backref" href="#id16">Previous Proposals</a></h1>
<p>This proposal is not a new idea.  The idea proposed here was supported
by the BDFL on python-dev <a class="footnote-reference" href="#id7" id="id1">[1]</a> and is even mentioned in the original
iterator PEP, <a class="reference external" href="/dev/peps/pep-0234">PEP 234</a>:</p>
<pre class="literal-block">
(In retrospect, it might have been better to go for __next__()
and have a new built-in, next(it), which calls it.__next__().
But alas, it's too late; this has been deployed in Python 2.2
since December 2001.)
</pre>
</div>
<div class="section" id="objections">
<h1><a class="toc-backref" href="#id17">Objections</a></h1>
<p>There have been a few objections to the addition of more built-ins.
In particular, Martin von Loewis writes <a class="footnote-reference" href="#id8" id="id2">[2]</a>:</p>
<pre class="literal-block">
I dislike the introduction of more builtins unless they have a true
generality (i.e. are likely to be needed in many programs). For this
one, I think the normal usage of __next__ will be with a for loop, so
I don't think one would often need an explicit next() invocation.

It is also not true that most protocols are explicitly invoked through
builtin functions. Instead, most protocols are can be explicitly invoked
through methods in the operator module. So following tradition, it
should be operator.next.

...

As an alternative, I propose that object grows a .next() method,
which calls __next__ by default.
</pre>
</div>
<div class="section" id="transition-plan">
<h1><a class="toc-backref" href="#id18">Transition Plan</a></h1>
<p>Two additional transformations will be added to the 2to3 translation
tool <a class="footnote-reference" href="#id9" id="id3">[3]</a>:</p>
<ul class="simple">
<li>Method definitions named <tt class="docutils literal"><span class="pre">next</span></tt> will be renamed to <tt class="docutils literal"><span class="pre">__next__</span></tt>.</li>
<li>Explicit calls to the <tt class="docutils literal"><span class="pre">next</span></tt> method will be replaced with calls
to the built-in <tt class="docutils literal"><span class="pre">next</span></tt> function.  For example, <tt class="docutils literal"><span class="pre">x.next()</span></tt> will
become <tt class="docutils literal"><span class="pre">next(x)</span></tt>.</li>
</ul>
<p>Collin Winter looked into the possibility of automatically deciding
whether to perform the second transformation depending on the presence
of a module-level binding to <tt class="docutils literal"><span class="pre">next</span></tt> <a class="footnote-reference" href="#id10" id="id4">[4]</a> and found that it would be
&quot;ugly and slow&quot;.  Instead, the translation tool will emit warnings
upon detecting such a binding.  Collin has proposed warnings for the
following conditions <a class="footnote-reference" href="#id11" id="id5">[5]</a>:</p>
<ul class="simple">
<li>Module-level assignments to <tt class="docutils literal"><span class="pre">next</span></tt>.</li>
<li>Module-level definitions of a function named <tt class="docutils literal"><span class="pre">next</span></tt>.</li>
<li>Module-level imports of the name <tt class="docutils literal"><span class="pre">next</span></tt>.</li>
<li>Assignments to <tt class="docutils literal"><span class="pre">__builtin__.next</span></tt>.</li>
</ul>
</div>
<div class="section" id="approval">
<h1><a class="toc-backref" href="#id19">Approval</a></h1>
<p>This PEP was accepted by Guido on March 6, 2007 <a class="footnote-reference" href="#id11" id="id6">[5]</a>.</p>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id20">Implementation</a></h1>
<p>A patch with the necessary changes (except the 2to3 tool) was written
by Georg Brandl and committed as revision 54910.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id21">References</a></h1>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Single- vs. Multi-pass iterability (Guido van Rossum)
<a class="reference external" href="http://mail.python.org/pipermail/python-dev/2002-July/026814.html">http://mail.python.org/pipermail/python-dev/2002-July/026814.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>PEP: rename it.next() to it.__next__()... (Martin von Loewis)
<a class="reference external" href="http://mail.python.org/pipermail/python-3000/2007-March/005965.html">http://mail.python.org/pipermail/python-3000/2007-March/005965.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>2to3 refactoring tool
<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/2to3/">http://svn.python.org/view/sandbox/trunk/2to3/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>PEP: rename it.next() to it.__next__()... (Collin Winter)
<a class="reference external" href="http://mail.python.org/pipermail/python-3000/2007-March/006020.html">http://mail.python.org/pipermail/python-3000/2007-March/006020.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference external" href="/dev/peps/pep-3113">PEP 3113</a> transition plan
<a class="reference external" href="http://mail.python.org/pipermail/python-3000/2007-March/006044.html">http://mail.python.org/pipermail/python-3000/2007-March/006044.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td>PEP: rename it.next() to it.__next__()... (Guido van Rossum)
<a class="reference external" href="http://mail.python.org/pipermail/python-3000/2007-March/006027.html">http://mail.python.org/pipermail/python-3000/2007-March/006027.html</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id22">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="pep-3114.txt">View document source</a>.
Generated on: 2013-09-17 06:14 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
