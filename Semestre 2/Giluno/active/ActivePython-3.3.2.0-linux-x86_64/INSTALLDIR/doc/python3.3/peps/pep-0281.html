<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 281 -- Loop Counter Iteration with range and xrange</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">

<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>281</td></tr>
  <tr><th>Title:&nbsp;</th><td>Loop Counter Iteration with range and xrange</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision: 56033 $</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="http://svn.python.org/view/peps/trunk/pep-0281.txt">$Date: 2007-06-18 21:20:07 -0700 (Mon, 18 Jun 2007) $</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Magnus Lie Hetland &lt;magnus&#32;&#97;t&#32;hetland.org&gt;</td></tr>
  <tr><th>Status:&nbsp;</th><td>Rejected</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Created:&nbsp;</th><td>11-Feb-2002</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>2.3</td></tr>
  <tr><th>Post-History:&nbsp;</th><td></td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Abstract</h3>
<pre>
   This PEP describes yet another way of exposing the loop counter in
   for-loops. It basically proposes that the functionality of the
   function indices() from <a href="pep-0212.html">PEP 212</a> [1] be included in the existing
   functions range() and xrange().

</pre>
<h3>Pronouncement</h3>
<pre>
   In commenting on <a href="pep-0279.html">PEP 279</a>'s enumerate() function, this PEP's author
   offered, "I'm quite happy to have it make <a href="pep-0281.html">PEP 281</a> obsolete."
   Subsequently, <a href="pep-0279.html">PEP 279</a> was accepted into Python 2.3.

   On 17 June 2005, the BDFL concurred with it being obsolete and
   hereby rejected the PEP.  For the record, he found some of the
   examples to somewhat jarring in appearance:

      &gt;&gt;&gt; range(range(5), range(10), range(2))
      [5, 7, 9]


</pre>
<h3>Motivation</h3>
<pre>
   It is often desirable to loop over the indices of a sequence.  PEP
   212 describes several ways of doing this, including adding a
   built-in function called indices, conceptually defined as

       def indices(sequence):
           return range(len(sequence))

   On the assumption that adding functionality to an existing built-in
   function may be less intrusive than adding a new built-in function,
   this PEP proposes adding this functionality to the existing
   functions range() and xrange().


</pre>
<h3>Specification</h3>
<pre>
   It is proposed that all three arguments to the built-in functions
   range() and xrange() are allowed to be objects with a length
   (i.e. objects implementing the __len__ method).  If an argument
   cannot be interpreted as an integer (i.e. it has no __int__
   method), its length will be used instead.

   Examples:

   &gt;&gt;&gt; range(range(10))
   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   &gt;&gt;&gt; range(range(5), range(10))
   [5, 6, 7, 8, 9]
   &gt;&gt;&gt; range(range(5), range(10), range(2))
   [5, 7, 9]
   &gt;&gt;&gt; list(xrange(range(10)))
   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   &gt;&gt;&gt; list(xrange(xrange(10)))
   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

   # Number the lines of a file:
   lines = file.readlines()
   for num in range(lines):
       print num, lines[num]


</pre>
<h3>Alternatives</h3>
<pre>
   A natural alternative to the above specification is allowing
   xrange() to access its arguments in a lazy manner.  Thus, instead
   of using their length explicitly, xrange can return one index for
   each element of the stop argument until the end is reached.  A
   similar lazy treatment makes little sense for the start and step
   arguments since their length must be calculated before iteration
   can begin.  (Actually, the length of the step argument isn't needed
   until the second element is returned.)

   A pseudo-implementation (using only the stop argument, and assuming
   that it is iterable) is:

   def xrange(stop):
       i = 0
       for x in stop:
           yield i
           i += 1

   Testing whether to use int() or lazy iteration could be done by
   checking for an __iter__ attribute.  (This example assumes the
   presence of generators, but could easily have been implemented as a
   plain iterator object.)

   It may be questionable whether this feature is truly useful, since
   one would not be able to access the elements of the iterable object
   inside the for loop through indexing.

   Example:

   # Printing the numbers of the lines of a file:
   for num in range(file):
       print num # The line itself is not accessible

   A more controversial alternative (to deal with this) would be to
   let range() behave like the function irange() of <a href="pep-0212.html">PEP 212</a> when
   supplied with a sequence.

   Example:

   &gt;&gt;&gt; range(5)
   [0, 1, 2, 3, 4]
   &gt;&gt;&gt; range('abcde')
   [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd'), (4, 'e')]


</pre>
<h3>Backwards Compatibility</h3>
<pre>
   The proposal could cause backwards incompatibilities if arguments
   are used which implement both __int__ and __len__ (or __iter__ in
   the case of lazy iteration with xrange).  The author does not
   believe that this is a significant problem.


</pre>
<h3>References and Footnotes</h3>
<pre>
   [1] <a href="pep-0212.html">PEP 212</a>, Loop Counter Iteration
       <a href="http://www.python.org/peps/pep-0212.html">http://www.python.org/peps/pep-0212.html</a>


</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.


</pre>
</div>
</body>
</html>
