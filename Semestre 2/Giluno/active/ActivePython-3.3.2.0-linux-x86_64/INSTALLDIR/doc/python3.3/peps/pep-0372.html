<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
  <title>PEP 372 -- Adding an ordered dictionary to collections</title>
  <link rel="stylesheet" href="pep.css" type="text/css" /></head>
<body bgcolor="white">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">372</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Adding an ordered dictionary to collections</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">64410</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-0372.txt">2008-06-19 13:51:39 -0700 (Thu, 19 Jun 2008)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Armin Ronacher &lt;armin.ronacher&#32;&#97;t&#32;active-4.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">15-Jun-2008</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.6, 3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id15">Abstract</a></li>
<li><a class="reference internal" href="#rationale" id="id16">Rationale</a></li>
<li><a class="reference internal" href="#ordered-dict-api" id="id17">Ordered Dict API</a></li>
<li><a class="reference internal" href="#python-3-version" id="id18">Python 3 Version</a></li>
<li><a class="reference internal" href="#questions-and-answers" id="id19">Questions and Answers</a></li>
<li><a class="reference internal" href="#example-implementation" id="id20">Example Implementation</a></li>
<li><a class="reference internal" href="#future-directions" id="id21">Future Directions</a></li>
<li><a class="reference internal" href="#references" id="id22">References</a></li>
<li><a class="reference internal" href="#copyright" id="id23">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id15">Abstract</a></h1>
<p>This PEP proposes an ordered dictionary as a new data structure for
the <tt class="docutils literal"><span class="pre">collections</span></tt> module, called &quot;odict&quot; in this PEP for short.  The
proposed API incorporates the experiences gained from working with
similar implementations that exist in various real-world applications
and other programming languages.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id16">Rationale</a></h1>
<p>In current Python versions, the widely used built-in dict type does
not specify an order for the key/value pairs stored.  This makes it
hard to use dictionaries as data storage for some specific use cases.</p>
<p>Some dynamic programming languages like PHP and Ruby 1.9 guarantee a
certain order on iteration.  In those languages, and existing Python
ordered-dict implementations, the ordering of items is defined by the
time of insertion of the key.  New keys are appended at the end, but
keys that are overwritten are not moved to the end.</p>
<p>The following example shows the behavior for simple assignments:</p>
<pre class="doctest-block">
&gt;&gt;&gt; d = odict()
&gt;&gt;&gt; d['parrot'] = 'dead'
&gt;&gt;&gt; d['penguin'] = 'exploded'
&gt;&gt;&gt; d.items()
[('parrot', 'dead'), ('penguin', 'exploded')]
</pre>
<p>That the ordering is preserved makes an odict useful for a couple of
situations:</p>
<ul>
<li><p class="first">XML/HTML processing libraries currently drop the ordering of
attributes, use a list instead of a dict which makes filtering
cumbersome, or implement their own ordered dictionary.  This affects
ElementTree, html5lib, Genshi and many more libraries.</p>
</li>
<li><p class="first">There are many ordered dict implementations in various libraries
and applications, most of them subtly incompatible with each other.
Furthermore, subclassing dict is a non-trivial task and many
implementations don't override all the methods properly which can
lead to unexpected results.</p>
<p>Additionally, many ordered dicts are implemented in an inefficient
way, making many operations more complex then they have to be.</p>
</li>
<li><p class="first"><a class="reference external" href="/dev/peps/pep-3115">PEP 3115</a> allows metaclasses to change the mapping object used for
the class body.  An ordered dict could be used to create ordered
member declarations similar to C structs.  This could be useful, for
example, for future <tt class="docutils literal"><span class="pre">ctypes</span></tt> releases as well as ORMs that define
database tables as classes, like the one the Django framework ships.
Django currently uses an ugly hack to restore the ordering of
members in database models.</p>
</li>
<li><p class="first">The RawConfigParser class accepts a <tt class="docutils literal"><span class="pre">dict_type</span></tt> argument that
allows an application to set the type of dictionary used internally.
The motivation for this addition was expressly to allow users to
provide an ordered dictionary. <a class="footnote-reference" href="#id2" id="id1">[1]</a></p>
</li>
<li><p class="first">Code ported from other programming languages such as PHP often
depends on a ordered dict.  Having an implementation of an
ordering-preserving dictionary in the standard library could ease
the transition and improve the compatibility of different libraries.</p>
</li>
</ul>
</div>
<div class="section" id="ordered-dict-api">
<h1><a class="toc-backref" href="#id17">Ordered Dict API</a></h1>
<p>The ordered dict API would be mostly compatible with dict and existing
ordered dicts.  (Note: this PEP refers to the Python 2.x dictionary
API; the transfer to the 3.x API is trivial.)</p>
<p>The constructor and <tt class="docutils literal"><span class="pre">update()</span></tt> both accept iterables of tuples as
well as mappings like a dict does.  The ordering however is preserved
for the first case:</p>
<pre class="doctest-block">
&gt;&gt;&gt; d = odict([('a', 'b'), ('c', 'd')])
&gt;&gt;&gt; d.update({'foo': 'bar'})
&gt;&gt;&gt; d
collections.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
</pre>
<p>If ordered dicts are updated from regular dicts, the ordering of new
keys is of course undefined again unless <tt class="docutils literal"><span class="pre">sort()</span></tt> is called.</p>
<p>All iteration methods as well as <tt class="docutils literal"><span class="pre">keys()</span></tt>, <tt class="docutils literal"><span class="pre">values()</span></tt> and
<tt class="docutils literal"><span class="pre">items()</span></tt> return the values ordered by the time the key-value pair
was inserted:</p>
<pre class="doctest-block">
&gt;&gt;&gt; d['spam'] = 'eggs'
&gt;&gt;&gt; d.keys()
['a', 'c', 'foo', 'spam']
&gt;&gt;&gt; d.values()
['b', 'd', 'bar', 'eggs']
&gt;&gt;&gt; d.items()
[('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', 'eggs')]
</pre>
<p>New methods not available on dict:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">odict.byindex(index)</span></tt></dt>
<dd><p class="first">Returns the key/value pair for an index, that is, the &quot;position&quot; of a key in
the ordered dict.  0 is the first key/value pair, -1 the last.</p>
<pre class="doctest-block">
&gt;&gt;&gt; d.byindex(2)
('foo', 'bar')
</pre>
<p class="last">If there is no key for index an <cite>IndexError</cite> is raised.  Slices are not
supported.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">odict.index(key)</span></tt></dt>
<dd>Returns the index of a key.  If the key does not exist, a <cite>ValueError</cite> is
raised.</dd>
<dt><tt class="docutils literal"><span class="pre">odict.sort(cmp=None,</span> <span class="pre">key=None,</span> <span class="pre">reverse=False)</span></tt></dt>
<dd><p class="first">Sorts the odict in place by cmp or key.  This works exactly like
<tt class="docutils literal"><span class="pre">list.sort()</span></tt>, but the comparison functions are passed a key/value tuple,
not only the value.</p>
<pre class="last doctest-block">
&gt;&gt;&gt; d = odict([(42, 1), (1, 4), (23, 7)]) d.sort() d
collections.odict([(1, 4), (23, 7), (42, 1)])
</pre>
</dd>
<dt><tt class="docutils literal"><span class="pre">odict.reverse()</span></tt></dt>
<dd>Reverses the odict in place.</dd>
<dt><tt class="docutils literal"><span class="pre">odict.__reversed__()</span></tt></dt>
<dd>Supports reverse iteration by key.</dd>
<dt><tt class="docutils literal"><span class="pre">odict.__eq__()</span></tt> / <tt class="docutils literal"><span class="pre">odict.__ne__()</span></tt></dt>
<dd>Compares the odict to another object.  If it's compared to another
odict the ordering of items is taken into account, otherwise only
the keys and values.</dd>
<dt><tt class="docutils literal"><span class="pre">odict.__cmp__()</span></tt></dt>
<dd>Ordered dicts are sorted by their items.  <tt class="docutils literal"><span class="pre">cmp(od1,</span> <span class="pre">od2)</span></tt> is
equivalent to <tt class="docutils literal"><span class="pre">cmp(od1.items(),</span> <span class="pre">od2.items())</span></tt> if both <tt class="docutils literal"><span class="pre">od1</span></tt>
and <tt class="docutils literal"><span class="pre">od2</span></tt> are ordered dicts.  Otherwise the regular dict comparison
kicks in.</dd>
</dl>
</div>
<div class="section" id="python-3-version">
<h1><a class="toc-backref" href="#id18">Python 3 Version</a></h1>
<p>The Python 3 version of the <tt class="docutils literal"><span class="pre">odict</span></tt> returns dictionary views rather
than lists for <tt class="docutils literal"><span class="pre">odict.keys()</span></tt>, <tt class="docutils literal"><span class="pre">odict.values()</span></tt> and
<tt class="docutils literal"><span class="pre">odict.items()</span></tt>.  The keys view is equivalent to a regular keys view
but supports the following extra or changed operations:</p>
<p><tt class="docutils literal"><span class="pre">odict_keys.__getitem__(index)</span></tt></p>
<blockquote>
Returns the key for an index.  This is equivalent to
<tt class="docutils literal"><span class="pre">odict.byindex(index)</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">odict_keys.index(key)</span></tt></p>
<blockquote>
Returns the index for a key.  This exists for compatibility with
the <tt class="docutils literal"><span class="pre">Sequence</span></tt> abstract base class and is equivalent to
<tt class="docutils literal"><span class="pre">odict.index(key)</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">odict_keys.__iter__()</span></tt></p>
<blockquote>
Has the same semantics as <tt class="docutils literal"><span class="pre">odict.__iter__()</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">odict_keys.__reversed__()</span></tt></p>
<blockquote>
Has the same semantics as <tt class="docutils literal"><span class="pre">odict.__reversed__()</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">odict_keys.__cmp__()</span></tt> / <tt class="docutils literal"><span class="pre">odict_keys.__eq__()</span></tt> /
<tt class="docutils literal"><span class="pre">odict_keys.__ne__()</span></tt></p>
<blockquote>
Same semantics as the equivalent <tt class="docutils literal"><span class="pre">odict</span></tt> operation.  E.g.: when
compared to another odict keys view the ordering is taken into
account.</blockquote>
</div>
<div class="section" id="questions-and-answers">
<h1><a class="toc-backref" href="#id19">Questions and Answers</a></h1>
<p>What happens if an existing key is reassigned?</p>
<blockquote>
<p>The key is not moved but assigned a new value in place.  This is
consistent with existing implementations and allows subclasses to
change the behavior easily:</p>
<pre class="literal-block">
class moving_odict(collections.odict):
    def __setitem__(self, key, value):
        self.pop(key, None)
        collections.odict.__setitem__(self, key, value)
</pre>
</blockquote>
<p>What happens if keys appear multiple times in the list passed to the
constructor?</p>
<blockquote>
<p>The same as for regular dicts: The latter item overrides the
former.  This has the side-effect that the position of the first
key is used because the key is actually overwritten:</p>
<pre class="doctest-block">
&gt;&gt;&gt; odict([('a', 1), ('b', 2), ('a', 3)])
collections.odict([('a', 3), ('b', 2)])
</pre>
<p>This behavior is consistent with existing implementations in
Python, the PHP array and the hashmap in Ruby 1.9.</p>
</blockquote>
<p>Why is there no <tt class="docutils literal"><span class="pre">odict.insert()</span></tt>?</p>
<blockquote>
<p>There are few situations where you really want to insert a key at
an specified index.  To avoid API complication, the proposed
solution for this situation is creating a list of items,
manipulating that and converting it back into an odict:</p>
<pre class="doctest-block">
&gt;&gt;&gt; d = odict([('a', 42), ('b', 23), ('c', 19)])
&gt;&gt;&gt; l = d.items()
&gt;&gt;&gt; l.insert(1, ('x', 0))
&gt;&gt;&gt; odict(l)
collections.odict([('a', 42), ('x', 0), ('b', 23), ('c', 19)])
</pre>
</blockquote>
<p>Is the ordered dict a dict subclass?</p>
<blockquote>
Yes.  Like <tt class="docutils literal"><span class="pre">defaultdict</span></tt>, <tt class="docutils literal"><span class="pre">odict</span></tt> subclasses <tt class="docutils literal"><span class="pre">dict</span></tt>.</blockquote>
<p>Does <tt class="docutils literal"><span class="pre">odict.pop()</span></tt> support list-like popping of items?</p>
<blockquote>
<p>No.  Neither <tt class="docutils literal"><span class="pre">odict.__getitem__()</span></tt> nor <tt class="docutils literal"><span class="pre">odict.pop()</span></tt> support
retrieving or deleting items by index.  Slices are not supported
either.  This would introduce ambiguities if integers or slice
objects are used as dict keys.</p>
<p>As a matter of fact, <tt class="docutils literal"><span class="pre">odict</span></tt> does not implement the <tt class="docutils literal"><span class="pre">Sequence</span></tt>
interface.</p>
</blockquote>
</div>
<div class="section" id="example-implementation">
<h1><a class="toc-backref" href="#id20">Example Implementation</a></h1>
<p>A poorly performing example implementation of the odict written in
Python is available:</p>
<blockquote>
<a class="reference external" href="http://dev.pocoo.org/hg/sandbox/raw-file/tip/odict.py">odict.py</a></blockquote>
<p>The version for <tt class="docutils literal"><span class="pre">collections</span></tt> should be implemented in C and use a
linked list internally.</p>
<p>Other implementations of ordered dicts in various Python projects or
standalone libraries, that inspired the API proposed here, are:</p>
<ul class="simple">
<li><a class="reference external" href="http://babel.edgewall.org/browser/trunk/babel/util.py?rev=374#L178">odict in Babel</a> <a class="footnote-reference" href="#id3" id="id4">[2]</a></li>
<li><a class="reference external" href="http://code.djangoproject.com/browser/django/trunk/django/utils/datastructures.py?rev=7140#L53">OrderedDict in Django</a> <a class="footnote-reference" href="#id5" id="id6">[3]</a></li>
<li><a class="reference external" href="http://www.voidspace.org.uk/python/odict.html">The odict module</a> <a class="footnote-reference" href="#id7" id="id8">[4]</a></li>
<li><a class="reference external" href="http://www.xs4all.nl/~anthon/Python/ordereddict/">ordereddict</a> <a class="footnote-reference" href="#id9" id="id10">[5]</a> (a C implementation of the odict module)</li>
<li><a class="reference external" href="http://pypi.python.org/pypi/StableDict/0.2">StableDict</a> <a class="footnote-reference" href="#id11" id="id12">[6]</a></li>
<li><a class="reference external" href="http://codespeak.net/svn/user/arigo/hack/pyfuse/OrderedDict.py">Armin Rigo's OrderedDict</a> <a class="footnote-reference" href="#id13" id="id14">[7]</a></li>
</ul>
</div>
<div class="section" id="future-directions">
<h1><a class="toc-backref" href="#id21">Future Directions</a></h1>
<p>With the availability of an ordered dict in the standard library,
other libraries may take advantage of that.  For example, ElementTree
could return odicts in the future that retain the attribute ordering
of the source file.</p>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id22">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://bugs.python.org/issue1371075">http://bugs.python.org/issue1371075</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td><a class="reference external" href="http://babel.edgewall.org/browser/trunk/babel/util.py?rev=374#L178">http://babel.edgewall.org/browser/trunk/babel/util.py?rev=374#L178</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[3]</a></td><td><a class="reference external" href="http://code.djangoproject.com/browser/django/trunk/django/utils/datastructures.py?rev=7140#L53">http://code.djangoproject.com/browser/django/trunk/django/utils/datastructures.py?rev=7140#L53</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[4]</a></td><td><a class="reference external" href="http://www.voidspace.org.uk/python/odict.html">http://www.voidspace.org.uk/python/odict.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[5]</a></td><td><a class="reference external" href="http://www.xs4all.nl/~anthon/Python/ordereddict/">http://www.xs4all.nl/~anthon/Python/ordereddict/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[6]</a></td><td><a class="reference external" href="http://pypi.python.org/pypi/StableDict/0.2">http://pypi.python.org/pypi/StableDict/0.2</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[7]</a></td><td><a class="reference external" href="http://codespeak.net/svn/user/arigo/hack/pyfuse/OrderedDict.py">http://codespeak.net/svn/user/arigo/hack/pyfuse/OrderedDict.py</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id23">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="pep-0372.txt">View document source</a>.
Generated on: 2013-09-17 06:14 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
