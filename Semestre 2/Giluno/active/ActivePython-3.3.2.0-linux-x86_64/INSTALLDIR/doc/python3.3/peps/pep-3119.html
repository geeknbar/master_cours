<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
  <title>PEP 3119 -- Introducing Abstract Base Classes</title>
  <link rel="stylesheet" href="pep.css" type="text/css" /></head>
<body bgcolor="white">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3119</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Introducing Abstract Base Classes</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">64010</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-3119.txt">2008-06-07 05:55:52 -0700 (Sat, 07 Jun 2008)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Guido van Rossum &lt;guido&#32;&#97;t&#32;python.org&gt;, Talin &lt;talin&#32;&#97;t&#32;acm.org&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">18-Apr-2007</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">26-Apr-2007, 11-May-2007</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id29">Abstract</a><ul>
<li><a class="reference internal" href="#acknowledgements" id="id30">Acknowledgements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rationale" id="id31">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id32">Specification</a><ul>
<li><a class="reference internal" href="#overloading-isinstance-and-issubclass" id="id33">Overloading <tt class="docutils literal"><span class="pre">isinstance()</span></tt> and <tt class="docutils literal"><span class="pre">issubclass()</span></tt></a></li>
<li><a class="reference internal" href="#the-abc-module-an-abc-support-framework" id="id34">The <tt class="docutils literal"><span class="pre">abc</span></tt> Module: an ABC Support Framework</a></li>
<li><a class="reference internal" href="#abcs-for-containers-and-iterators" id="id35">ABCs for Containers and Iterators</a><ul>
<li><a class="reference internal" href="#one-trick-ponies" id="id36">One Trick Ponies</a></li>
<li><a class="reference internal" href="#sets" id="id37">Sets</a></li>
<li><a class="reference internal" href="#mappings" id="id38">Mappings</a></li>
<li><a class="reference internal" href="#sequences" id="id39">Sequences</a></li>
</ul>
</li>
<li><a class="reference internal" href="#strings" id="id40">Strings</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abcs-vs-alternatives" id="id41">ABCs vs. Alternatives</a><ul>
<li><a class="reference internal" href="#abcs-vs-duck-typing" id="id42">ABCs vs. Duck Typing</a></li>
<li><a class="reference internal" href="#abcs-vs-generic-functions" id="id43">ABCs vs. Generic Functions</a></li>
<li><a class="reference internal" href="#abcs-vs-interfaces" id="id44">ABCs vs. Interfaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id45">References</a></li>
<li><a class="reference internal" href="#copyright" id="id46">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id29">Abstract</a></h1>
<p>This is a proposal to add Abstract Base Class (ABC) support to Python
3000.  It proposes:</p>
<ul class="simple">
<li>A way to overload <tt class="docutils literal"><span class="pre">isinstance()</span></tt> and <tt class="docutils literal"><span class="pre">issubclass()</span></tt>.</li>
<li>A new module <tt class="docutils literal"><span class="pre">abc</span></tt> which serves as an &quot;ABC support framework&quot;.  It
defines a metaclass for use with ABCs and a decorator that can be
used to define abstract methods.</li>
<li>Specific ABCs for containers and iterators, to be added to the
collections module.</li>
</ul>
<p>Much of the thinking that went into the proposal is not about the
specific mechanism of ABCs, as contrasted with Interfaces or Generic
Functions (GFs), but about clarifying philosophical issues like &quot;what
makes a set&quot;, &quot;what makes a mapping&quot; and &quot;what makes a sequence&quot;.</p>
<p>There's also a companion <a class="reference external" href="/dev/peps/pep-3141">PEP 3141</a>, which defines ABCs for numeric
types.</p>
<div class="section" id="acknowledgements">
<h2><a class="toc-backref" href="#id30">Acknowledgements</a></h2>
<p>Talin wrote the Rationale below <a class="footnote-reference" href="#id13" id="id1">[1]</a> as well as most of the section on
ABCs vs. Interfaces.  For that alone he deserves co-authorship.  The
rest of the PEP uses &quot;I&quot; referring to the first author.</p>
</div>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id31">Rationale</a></h1>
<p>In the domain of object-oriented programming, the usage patterns for
interacting with an object can be divided into two basic categories,
which are 'invocation' and 'inspection'.</p>
<p>Invocation means interacting with an object by invoking its methods.
Usually this is combined with polymorphism, so that invoking a given
method may run different code depending on the type of an object.</p>
<p>Inspection means the ability for external code (outside of the
object's methods) to examine the type or properties of that object,
and make decisions on how to treat that object based on that
information.</p>
<p>Both usage patterns serve the same general end, which is to be able to
support the processing of diverse and potentially novel objects in a
uniform way, but at the same time allowing processing decisions to be
customized for each different type of object.</p>
<p>In classical OOP theory, invocation is the preferred usage pattern,
and inspection is actively discouraged, being considered a relic of an
earlier, procedural programming style.  However, in practice this view
is simply too dogmatic and inflexible, and leads to a kind of design
rigidity that is very much at odds with the dynamic nature of a
language like Python.</p>
<p>In particular, there is often a need to process objects in a way that
wasn't anticipated by the creator of the object class.  It is not
always the best solution to build in to every object methods that
satisfy the needs of every possible user of that object.  Moreover,
there are many powerful dispatch philosophies that are in direct
contrast to the classic OOP requirement of behavior being strictly
encapsulated within an object, examples being rule or pattern-match
driven logic.</p>
<p>On the other hand, one of the criticisms of inspection by classic
OOP theorists is the lack of formalisms and the ad hoc nature of what
is being inspected.  In a language such as Python, in which almost any
aspect of an object can be reflected and directly accessed by external
code, there are many different ways to test whether an object conforms
to a particular protocol or not.  For example, if asking 'is this
object a mutable sequence container?', one can look for a base class
of 'list', or one can look for a method named '__getitem__'.  But note
that although these tests may seem obvious, neither of them are
correct, as one generates false negatives, and the other false
positives.</p>
<p>The generally agreed-upon remedy is to standardize the tests, and
group them into a formal arrangement.  This is most easily done by
associating with each class a set of standard testable properties,
either via the inheritance mechanism or some other means.  Each test
carries with it a set of promises: it contains a promise about the
general behavior of the class, and a promise as to what other class
methods will be available.</p>
<p>This PEP proposes a particular strategy for organizing these tests
known as Abstract Base Classes, or ABC.  ABCs are simply Python
classes that are added into an object's inheritance tree to signal
certain features of that object to an external inspector.  Tests are
done using <tt class="docutils literal"><span class="pre">isinstance()</span></tt>, and the presence of a particular ABC
means that the test has passed.</p>
<p>In addition, the ABCs define a minimal set of methods that establish
the characteristic behavior of the type.  Code that discriminates
objects based on their ABC type can trust that those methods will
always be present.  Each of these methods are accompanied by an
generalized abstract semantic definition that is described in the
documentation for the ABC.  These standard semantic definitions are
not enforced, but are strongly recommended.</p>
<p>Like all other things in Python, these promises are in the nature of a
gentlemen's agreement, which in this case means that while the
language does enforce some of the promises made in the ABC, it is up
to the implementer of the concrete class to insure that the remaining
ones are kept.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id32">Specification</a></h1>
<p>The specification follows the categories listed in the abstract:</p>
<ul class="simple">
<li>A way to overload <tt class="docutils literal"><span class="pre">isinstance()</span></tt> and <tt class="docutils literal"><span class="pre">issubclass()</span></tt>.</li>
<li>A new module <tt class="docutils literal"><span class="pre">abc</span></tt> which serves as an &quot;ABC support framework&quot;.  It
defines a metaclass for use with ABCs and a decorator that can be
used to define abstract methods.</li>
<li>Specific ABCs for containers and iterators, to be added to the
collections module.</li>
</ul>
<div class="section" id="overloading-isinstance-and-issubclass">
<h2><a class="toc-backref" href="#id33">Overloading <tt class="docutils literal"><span class="pre">isinstance()</span></tt> and <tt class="docutils literal"><span class="pre">issubclass()</span></tt></a></h2>
<p>During the development of this PEP and of its companion, <a class="reference external" href="/dev/peps/pep-3141">PEP 3141</a>, we
repeatedly faced the choice between standardizing more, fine-grained
ABCs or fewer, course-grained ones.  For example, at one stage, <a class="reference external" href="/dev/peps/pep-3141">PEP
3141</a> introduced the following stack of base classes used for complex
numbers: MonoidUnderPlus, AdditiveGroup, Ring, Field, Complex (each
derived from the previous).  And the discussion mentioned several
other algebraic categorizations that were left out: Algebraic,
Transcendental, and IntegralDomain, and PrincipalIdealDomain.  In
earlier versions of the current PEP, we considered the use cases for
separate classes like Set, ComposableSet, MutableSet, HashableSet,
MutableComposableSet, HashableComposableSet.</p>
<p>The dilemma here is that we'd rather have fewer ABCs, but then what
should a user do who needs a less refined ABC?  Consider e.g. the
plight of a mathematician who wants to define his own kind of
Transcendental numbers, but also wants float and int to be considered
Transcendental.  <a class="reference external" href="/dev/peps/pep-3141">PEP 3141</a> originally proposed to patch float.__bases__
for that purpose, but there are some good reasons to keep the built-in
types immutable (for one, they are shared between all Python
interpreters running in the same address space, as is used by
mod_python <a class="footnote-reference" href="#id28" id="id2">[16]</a>).</p>
<p>Another example would be someone who wants to define a generic
function (<a class="reference external" href="/dev/peps/pep-3124">PEP 3124</a>) for any sequence that has an <tt class="docutils literal"><span class="pre">append()</span></tt> method.
The <tt class="docutils literal"><span class="pre">Sequence</span></tt> ABC (see below) doesn't promise the <tt class="docutils literal"><span class="pre">append()</span></tt>
method, while <tt class="docutils literal"><span class="pre">MutableSequence</span></tt> requires not only <tt class="docutils literal"><span class="pre">append()</span></tt> but
also various other mutating methods.</p>
<p>To solve these and similar dilemmas, the next section will propose a
metaclass for use with ABCs that will allow us to add an ABC as a
&quot;virtual base class&quot; (not the same concept as in C++) to any class,
including to another ABC.  This allows the standard library to define
ABCs <tt class="docutils literal"><span class="pre">Sequence</span></tt> and <tt class="docutils literal"><span class="pre">MutableSequence</span></tt> and register these as
virtual base classes for built-in types like <tt class="docutils literal"><span class="pre">basestring</span></tt>, <tt class="docutils literal"><span class="pre">tuple</span></tt>
and <tt class="docutils literal"><span class="pre">list</span></tt>, so that for example the following conditions are all
true:</p>
<pre class="literal-block">
isinstance([], Sequence)
issubclass(list, Sequence)
issubclass(list, MutableSequence)
isinstance((), Sequence)
not issubclass(tuple, MutableSequence)
isinstance(&quot;&quot;, Sequence)
issubclass(bytearray, MutableSequence)
</pre>
<p>The primary mechanism proposed here is to allow overloading the
built-in functions <tt class="docutils literal"><span class="pre">isinstance()</span></tt> and <tt class="docutils literal"><span class="pre">issubclass()</span></tt>.  The
overloading works as follows: The call <tt class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">C)</span></tt> first
checks whether <tt class="docutils literal"><span class="pre">C.__instancecheck__</span></tt> exists, and if so, calls
<tt class="docutils literal"><span class="pre">C.__instancecheck__(x)</span></tt> instead of its normal implementation.
Similarly, the call <tt class="docutils literal"><span class="pre">issubclass(D,</span> <span class="pre">C)</span></tt> first checks whether
<tt class="docutils literal"><span class="pre">C.__subclasscheck__</span></tt> exists, and if so, calls
<tt class="docutils literal"><span class="pre">C.__subclasscheck__(D)</span></tt> instead of its normal implementation.</p>
<p>Note that the magic names are not <tt class="docutils literal"><span class="pre">__isinstance__</span></tt> and
<tt class="docutils literal"><span class="pre">__issubclass__</span></tt>; this is because the reversal of the arguments
could cause confusion, especially for the <tt class="docutils literal"><span class="pre">issubclass()</span></tt> overloader.</p>
<p>A prototype implementation of this is given in <a class="footnote-reference" href="#id24" id="id3">[12]</a>.</p>
<p>Here is an example with (naively simple) implementations of
<tt class="docutils literal"><span class="pre">__instancecheck__</span></tt> and <tt class="docutils literal"><span class="pre">__subclasscheck__</span></tt>:</p>
<pre class="literal-block">
class ABCMeta(type):

    def __instancecheck__(cls, inst):
        &quot;&quot;&quot;Implement isinstance(inst, cls).&quot;&quot;&quot;
        return any(cls.__subclasscheck__(c)
                   for c in {type(inst), inst.__class__})

    def __subclasscheck__(cls, sub):
        &quot;&quot;&quot;Implement issubclass(sub, cls).&quot;&quot;&quot;
        candidates = cls.__dict__.get(&quot;__subclass__&quot;, set()) | {cls}
        return any(c in candidates for c in sub.mro())

class Sequence(metaclass=ABCMeta):
    __subclass__ = {list, tuple}

assert issubclass(list, Sequence)
assert issubclass(tuple, Sequence)

class AppendableSequence(Sequence):
    __subclass__ = {list}

assert issubclass(list, AppendableSequence)
assert isinstance([], AppendableSequence)

assert not issubclass(tuple, AppendableSequence)
assert not isinstance((), AppendableSequence)
</pre>
<p>The next section proposes a full-fledged implementation.</p>
</div>
<div class="section" id="the-abc-module-an-abc-support-framework">
<h2><a class="toc-backref" href="#id34">The <tt class="docutils literal"><span class="pre">abc</span></tt> Module: an ABC Support Framework</a></h2>
<p>The new standard library module <tt class="docutils literal"><span class="pre">abc</span></tt>, written in pure Python,
serves as an ABC support framework.  It defines a metaclass
<tt class="docutils literal"><span class="pre">ABCMeta</span></tt> and decorators <tt class="docutils literal"><span class="pre">&#64;abstractmethod</span></tt> and
<tt class="docutils literal"><span class="pre">&#64;abstractproperty</span></tt>.  A sample implementation is given by <a class="footnote-reference" href="#id25" id="id4">[13]</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">ABCMeta</span></tt> class overrides <tt class="docutils literal"><span class="pre">__instancecheck__</span></tt> and
<tt class="docutils literal"><span class="pre">__subclasscheck__</span></tt> and defines a <tt class="docutils literal"><span class="pre">register</span></tt> method.  The
<tt class="docutils literal"><span class="pre">register</span></tt> method takes one argument, which must be a class; after
the call <tt class="docutils literal"><span class="pre">B.register(C)</span></tt>, the call <tt class="docutils literal"><span class="pre">issubclass(C,</span> <span class="pre">B)</span></tt> will return
True, by virtue of <tt class="docutils literal"><span class="pre">B.__subclasscheck__(C)</span></tt> returning True.
Also, <tt class="docutils literal"><span class="pre">isinstance(x,</span> <span class="pre">B)</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">issubclass(x.__class__,</span>
<span class="pre">B)</span> <span class="pre">or</span> <span class="pre">issubclass(type(x),</span> <span class="pre">B)</span></tt>.  (It is possible <tt class="docutils literal"><span class="pre">type(x)</span></tt> and
<tt class="docutils literal"><span class="pre">x.__class__</span></tt> are not the same object, e.g. when x is a proxy
object.)</p>
<p>These methods are intended to be be called on classes whose metaclass
is (derived from) <tt class="docutils literal"><span class="pre">ABCMeta</span></tt>; for example:</p>
<pre class="literal-block">
from abc import ABCMeta

class MyABC(metaclass=ABCMeta):
    pass

MyABC.register(tuple)

assert issubclass(tuple, MyABC)
assert isinstance((), MyABC)
</pre>
<p>The last two asserts are equivalent to the following two:</p>
<pre class="literal-block">
assert MyABC.__subclasscheck__(tuple)
assert MyABC.__instancecheck__(())
</pre>
<p>Of course, you can also directly subclass MyABC:</p>
<pre class="literal-block">
class MyClass(MyABC):
    pass

assert issubclass(MyClass, MyABC)
assert isinstance(MyClass(), MyABC)
</pre>
<p>Also, of course, a tuple is not a <tt class="docutils literal"><span class="pre">MyClass</span></tt>:</p>
<pre class="literal-block">
assert not issubclass(tuple, MyClass)
assert not isinstance((), MyClass)
</pre>
<p>You can register another class as a subclass of <tt class="docutils literal"><span class="pre">MyClass</span></tt>:</p>
<pre class="literal-block">
MyClass.register(list)

assert issubclass(list, MyClass)
assert issubclass(list, MyABC)
</pre>
<p>You can also register another ABC:</p>
<pre class="literal-block">
class AnotherClass(metaclass=ABCMeta):
    pass

AnotherClass.register(basestring)

MyClass.register(AnotherClass)

assert isinstance(str, MyABC)
</pre>
<p>That last assert requires tracing the following superclass-subclass
relationships:</p>
<pre class="literal-block">
MyABC -&gt; MyClass (using regular subclassing)
MyClass -&gt; AnotherClass (using registration)
AnotherClass -&gt; basestring (using registration)
basestring -&gt; str (using regular subclassing)
</pre>
<p>The <tt class="docutils literal"><span class="pre">abc</span></tt> module also defines a new decorator, <tt class="docutils literal"><span class="pre">&#64;abstractmethod</span></tt>,
to be used to declare abstract methods.  A class containing at least
one method declared with this decorator that hasn't been overridden
yet cannot be instantiated.  Such methods may be called from the
overriding method in the subclass (using <tt class="docutils literal"><span class="pre">super</span></tt> or direct
invocation).  For example:</p>
<pre class="literal-block">
from abc import ABCMeta, abstractmethod

class A(metaclass=ABCMeta):
    &#64;abstractmethod
    def foo(self): pass

A()  # raises TypeError

class B(A):
    pass

B()  # raises TypeError

class C(A):
    def foo(self): print(42)

C()  # works
</pre>
<p><strong>Note:</strong> The <tt class="docutils literal"><span class="pre">&#64;abstractmethod</span></tt> decorator should only be used
inside a class body, and only for classes whose metaclass is (derived
from) <tt class="docutils literal"><span class="pre">ABCMeta</span></tt>.  Dynamically adding abstract methods to a class, or
attempting to modify the abstraction status of a method or class once
it is created, are not supported.  The <tt class="docutils literal"><span class="pre">&#64;abstractmethod</span></tt> only
affects subclasses derived using regular inheritance; &quot;virtual
subclasses&quot; registered with the <tt class="docutils literal"><span class="pre">register()</span></tt> method are not affected.</p>
<p><strong>Implementation:</strong> The <tt class="docutils literal"><span class="pre">&#64;abstractmethod</span></tt> decorator sets the
function attribute <tt class="docutils literal"><span class="pre">__isabstractmethod__</span></tt> to the value <tt class="docutils literal"><span class="pre">True</span></tt>.
The <tt class="docutils literal"><span class="pre">ABCMeta.__new__</span></tt> method computes the type attribute
<tt class="docutils literal"><span class="pre">__abstractmethods__</span></tt> as the set of all method names that have an
<tt class="docutils literal"><span class="pre">__isabstractmethod__</span></tt> attribute whose value is true.  It does this
by combining the <tt class="docutils literal"><span class="pre">__abstractmethods__</span></tt> attributes of the base
classes, adding the names of all methods in the new class dict that
have a true <tt class="docutils literal"><span class="pre">__isabstractmethod__</span></tt> attribute, and removing the names
of all methods in the new class dict that don't have a true
<tt class="docutils literal"><span class="pre">__isabstractmethod__</span></tt> attribute.  If the resulting
<tt class="docutils literal"><span class="pre">__abstractmethods__</span></tt> set is non-empty, the class is considered
abstract, and attempts to instantiate it will raise <tt class="docutils literal"><span class="pre">TypeError</span></tt>.
(If this were implemented in CPython, an internal flag
<tt class="docutils literal"><span class="pre">Py_TPFLAGS_ABSTRACT</span></tt> could be used to speed up this check <a class="footnote-reference" href="#id18" id="id5">[6]</a>.)</p>
<p><strong>Discussion:</strong> Unlike Java's abstract methods or C++'s pure abstract
methods, abstract methods as defined here may have an implementation.
This implementation can be called via the <tt class="docutils literal"><span class="pre">super</span></tt> mechanism from the
class that overrides it.  This could be useful as an end-point for a
super-call in framework using cooperative multiple-inheritance <a class="footnote-reference" href="#id19" id="id6">[7]</a>,
<a class="footnote-reference" href="#id20" id="id7">[8]</a>.</p>
<p>A second decorator, <tt class="docutils literal"><span class="pre">&#64;abstractproperty</span></tt>, is defined in order to
define abstract data attributes.  Its implementation is a subclass of
the built-in <tt class="docutils literal"><span class="pre">property</span></tt> class that adds an <tt class="docutils literal"><span class="pre">__isabstractmethod__</span></tt>
attribute:</p>
<pre class="literal-block">
class abstractproperty(property):
    __isabstractmethod__ = True
</pre>
<p>It can be used in two ways:</p>
<pre class="literal-block">
class C(metaclass=ABCMeta):

    # A read-only property:

    &#64;abstractproperty
    def readonly(self):
        return self.__x

    # A read-write property (cannot use decorator syntax):

    def getx(self):
        return self.__x
    def setx(self, value):
        self.__x = value
    x = abstractproperty(getx, setx)
</pre>
<p>Similar to abstract methods, a subclass inheriting an abstract
property (declared using either the decorator syntax or the longer
form) cannot be instantiated unless it overrides that abstract
property with a concrete property.</p>
</div>
<div class="section" id="abcs-for-containers-and-iterators">
<h2><a class="toc-backref" href="#id35">ABCs for Containers and Iterators</a></h2>
<p>The <tt class="docutils literal"><span class="pre">collections</span></tt> module will define ABCs necessary and sufficient
to work with sets, mappings, sequences, and some helper types such as
iterators and dictionary views.  All ABCs have the above-mentioned
<tt class="docutils literal"><span class="pre">ABCMeta</span></tt> as their metaclass.</p>
<p>The ABCs provide implementations of their abstract methods that are
technically valid but fairly useless; e.g. <tt class="docutils literal"><span class="pre">__hash__</span></tt> returns 0, and
<tt class="docutils literal"><span class="pre">__iter__</span></tt> returns an empty iterator.  In general, the abstract
methods represent the behavior of an empty container of the indicated
type.</p>
<p>Some ABCs also provide concrete (i.e. non-abstract) methods; for
example, the <tt class="docutils literal"><span class="pre">Iterator</span></tt> class has an <tt class="docutils literal"><span class="pre">__iter__</span></tt> method returning
itself, fulfilling an important invariant of iterators (which in
Python 2 has to be implemented anew by each iterator class).  These
ABCs can be considered &quot;mix-in&quot; classes.</p>
<p>No ABCs defined in the PEP override <tt class="docutils literal"><span class="pre">__init__</span></tt>, <tt class="docutils literal"><span class="pre">__new__</span></tt>,
<tt class="docutils literal"><span class="pre">__str__</span></tt> or <tt class="docutils literal"><span class="pre">__repr__</span></tt>.  Defining a standard constructor
signature would unnecessarily constrain custom container types, for
example Patricia trees or gdbm files.  Defining a specific string
representation for a collection is similarly left up to individual
implementations.</p>
<p><strong>Note:</strong> There are no ABCs for ordering operations (<tt class="docutils literal"><span class="pre">__lt__</span></tt>,
<tt class="docutils literal"><span class="pre">__le__</span></tt>, <tt class="docutils literal"><span class="pre">__ge__</span></tt>, <tt class="docutils literal"><span class="pre">__gt__</span></tt>).  Defining these in a base class
(abstract or not) runs into problems with the accepted type for the
second operand.  For example, if class <tt class="docutils literal"><span class="pre">Ordering</span></tt> defined
<tt class="docutils literal"><span class="pre">__lt__</span></tt>, one would assume that for any <tt class="docutils literal"><span class="pre">Ordering</span></tt> instances <tt class="docutils literal"><span class="pre">x</span></tt>
and <tt class="docutils literal"><span class="pre">y</span></tt>, <tt class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></tt> would be defined (even if it just defines a
partial ordering).  But this cannot be the case: If both <tt class="docutils literal"><span class="pre">list</span></tt> and
<tt class="docutils literal"><span class="pre">str</span></tt> derived from <tt class="docutils literal"><span class="pre">Ordering</span></tt>, this would imply that <tt class="docutils literal"><span class="pre">[1,</span> <span class="pre">2]</span> <span class="pre">&lt;</span>
<span class="pre">(1,</span> <span class="pre">2)</span></tt> should be defined (and presumably return False), while in
fact (in Python 3000!)  such &quot;mixed-mode comparisons&quot; operations are
explicitly forbidden and raise <tt class="docutils literal"><span class="pre">TypeError</span></tt>.  See <a class="reference external" href="/dev/peps/pep-3100">PEP 3100</a> and <a class="footnote-reference" href="#id26" id="id8">[14]</a>
for more information.  (This is a special case of a more general issue
with operations that take another argument of the same type).</p>
<div class="section" id="one-trick-ponies">
<h3><a class="toc-backref" href="#id36">One Trick Ponies</a></h3>
<p>These abstract classes represent single methods like <tt class="docutils literal"><span class="pre">__iter__</span></tt> or
<tt class="docutils literal"><span class="pre">__len__</span></tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Hashable</span></tt></dt>
<dd><p class="first">The base class for classes defining <tt class="docutils literal"><span class="pre">__hash__</span></tt>.  The
<tt class="docutils literal"><span class="pre">__hash__</span></tt> method should return an integer.  The abstract
<tt class="docutils literal"><span class="pre">__hash__</span></tt> method always returns 0, which is a valid (albeit
inefficient) implementation.  <strong>Invariant:</strong> If classes <tt class="docutils literal"><span class="pre">C1</span></tt> and
<tt class="docutils literal"><span class="pre">C2</span></tt> both derive from <tt class="docutils literal"><span class="pre">Hashable</span></tt>, the condition <tt class="docutils literal"><span class="pre">o1</span> <span class="pre">==</span> <span class="pre">o2</span></tt>
must imply <tt class="docutils literal"><span class="pre">hash(o1)</span> <span class="pre">==</span> <span class="pre">hash(o2)</span></tt> for all instances <tt class="docutils literal"><span class="pre">o1</span></tt> of
<tt class="docutils literal"><span class="pre">C1</span></tt> and all instances <tt class="docutils literal"><span class="pre">o2</span></tt> of <tt class="docutils literal"><span class="pre">C2</span></tt>.  In other words, two
objects should never compare equal if they have different hash
values.</p>
<p>Another constraint is that hashable objects, once created, should
never change their value (as compared by <tt class="docutils literal"><span class="pre">==</span></tt>) or their hash
value.  If a class cannot guarantee this, it should not derive
from <tt class="docutils literal"><span class="pre">Hashable</span></tt>; if it cannot guarantee this for certain
instances, <tt class="docutils literal"><span class="pre">__hash__</span></tt> for those instances should raise a
<tt class="docutils literal"><span class="pre">TypeError</span></tt> exception.</p>
<p class="last"><strong>Note:</strong> being an instance of this class does not imply that an
object is immutable; e.g. a tuple containing a list as a member is
not immutable; its <tt class="docutils literal"><span class="pre">__hash__</span></tt> method raises <tt class="docutils literal"><span class="pre">TypeError</span></tt>.
(This is because it recursively tries to compute the hash of each
member; if a member is unhashable it raises <tt class="docutils literal"><span class="pre">TypeError</span></tt>.)</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">Iterable</span></tt></dt>
<dd>The base class for classes defining <tt class="docutils literal"><span class="pre">__iter__</span></tt>.  The
<tt class="docutils literal"><span class="pre">__iter__</span></tt> method should always return an instance of
<tt class="docutils literal"><span class="pre">Iterator</span></tt> (see below).  The abstract <tt class="docutils literal"><span class="pre">__iter__</span></tt> method
returns an empty iterator.</dd>
<dt><tt class="docutils literal"><span class="pre">Iterator</span></tt></dt>
<dd>The base class for classes defining <tt class="docutils literal"><span class="pre">__next__</span></tt>.  This derives
from <tt class="docutils literal"><span class="pre">Iterable</span></tt>.  The abstract <tt class="docutils literal"><span class="pre">__next__</span></tt> method raises
<tt class="docutils literal"><span class="pre">StopIteration</span></tt>.  The concrete <tt class="docutils literal"><span class="pre">__iter__</span></tt> method returns
<tt class="docutils literal"><span class="pre">self</span></tt>.  Note the distinction between <tt class="docutils literal"><span class="pre">Iterable</span></tt> and
<tt class="docutils literal"><span class="pre">Iterator</span></tt>: an <tt class="docutils literal"><span class="pre">Iterable</span></tt> can be iterated over, i.e. supports
the <tt class="docutils literal"><span class="pre">__iter__</span></tt> methods; an <tt class="docutils literal"><span class="pre">Iterator</span></tt> is what the built-in
function <tt class="docutils literal"><span class="pre">iter()</span></tt> returns, i.e. supports the <tt class="docutils literal"><span class="pre">__next__</span></tt>
method.</dd>
<dt><tt class="docutils literal"><span class="pre">Sized</span></tt></dt>
<dd>The base class for classes defining <tt class="docutils literal"><span class="pre">__len__</span></tt>.  The <tt class="docutils literal"><span class="pre">__len__</span></tt>
method should return an <tt class="docutils literal"><span class="pre">Integer</span></tt> (see &quot;Numbers&quot; below) &gt;= 0.
The abstract <tt class="docutils literal"><span class="pre">__len__</span></tt> method returns 0.  <strong>Invariant:</strong> If a
class <tt class="docutils literal"><span class="pre">C</span></tt> derives from <tt class="docutils literal"><span class="pre">Sized</span></tt> as well as from <tt class="docutils literal"><span class="pre">Iterable</span></tt>,
the invariant <tt class="docutils literal"><span class="pre">sum(1</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">c)</span> <span class="pre">==</span> <span class="pre">len(c)</span></tt> should hold for any
instance <tt class="docutils literal"><span class="pre">c</span></tt> of <tt class="docutils literal"><span class="pre">C</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">Container</span></tt></dt>
<dd>The base class for classes defining <tt class="docutils literal"><span class="pre">__contains__</span></tt>.  The
<tt class="docutils literal"><span class="pre">__contains__</span></tt> method should return a <tt class="docutils literal"><span class="pre">bool</span></tt>.  The abstract
<tt class="docutils literal"><span class="pre">__contains__</span></tt> method returns <tt class="docutils literal"><span class="pre">False</span></tt>.  <strong>Invariant:</strong> If a
class <tt class="docutils literal"><span class="pre">C</span></tt> derives from <tt class="docutils literal"><span class="pre">Container</span></tt> as well as from
<tt class="docutils literal"><span class="pre">Iterable</span></tt>, then <tt class="docutils literal"><span class="pre">(x</span> <span class="pre">in</span> <span class="pre">c</span> <span class="pre">for</span> <span class="pre">x</span> <span class="pre">in</span> <span class="pre">c)</span></tt> should be a generator
yielding only True values for any instance <tt class="docutils literal"><span class="pre">c</span></tt> of <tt class="docutils literal"><span class="pre">C</span></tt>.</dd>
</dl>
<p><strong>Open issues:</strong> Conceivably, instead of using the ABCMeta metaclass,
these classes could override <tt class="docutils literal"><span class="pre">__instancecheck__</span></tt> and
<tt class="docutils literal"><span class="pre">__subclasscheck__</span></tt> to check for the presence of the applicable
special method; for example:</p>
<pre class="literal-block">
class Sized(metaclass=ABCMeta):
    &#64;abstractmethod
    def __hash__(self):
        return 0
    &#64;classmethod
    def __instancecheck__(cls, x):
        return hasattr(x, &quot;__len__&quot;)
    &#64;classmethod
    def __subclasscheck__(cls, C):
        return hasattr(C, &quot;__bases__&quot;) and hasattr(C, &quot;__len__&quot;)
</pre>
<p>This has the advantage of not requiring explicit registration.
However, the semantics are hard to get exactly right given the confusing
semantics of instance attributes vs. class attributes, and that a
class is an instance of its metaclass; the check for <tt class="docutils literal"><span class="pre">__bases__</span></tt> is
only an approximation of the desired semantics.  <strong>Strawman:</strong> Let's
do it, but let's arrange it in such a way that the registration API
also works.</p>
</div>
<div class="section" id="sets">
<h3><a class="toc-backref" href="#id37">Sets</a></h3>
<p>These abstract classes represent read-only sets and mutable sets.  The
most fundamental set operation is the membership test, written as <tt class="docutils literal"><span class="pre">x</span>
<span class="pre">in</span> <span class="pre">s</span></tt> and implemented by <tt class="docutils literal"><span class="pre">s.__contains__(x)</span></tt>.  This operation is
already defined by the <tt class="docutils literal"><span class="pre">Container</span></tt> class defined above.  Therefore,
we define a set as a sized, iterable container for which certain
invariants from mathematical set theory hold.</p>
<p>The built-in type <tt class="docutils literal"><span class="pre">set</span></tt> derives from <tt class="docutils literal"><span class="pre">MutableSet</span></tt>.  The built-in
type <tt class="docutils literal"><span class="pre">frozenset</span></tt> derives from <tt class="docutils literal"><span class="pre">Set</span></tt> and <tt class="docutils literal"><span class="pre">Hashable</span></tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Set</span></tt></dt>
<dd><p class="first">This is a sized, iterable container, i.e., a subclass of
<tt class="docutils literal"><span class="pre">Sized</span></tt>, <tt class="docutils literal"><span class="pre">Iterable</span></tt> and <tt class="docutils literal"><span class="pre">Container</span></tt>.  Not every subclass of
those three classes is a set though!  Sets have the additional
invariant that each element occurs only once (as can be determined
by iteration), and in addition sets define concrete operators that
implement the inequality operations as subclass/superclass tests.
In general, the invariants for finite sets in mathematics
hold. <a class="footnote-reference" href="#id23" id="id9">[11]</a></p>
<p>Sets with different implementations can be compared safely,
(usually) efficiently and correctly using the mathematical
definitions of the subclass/superclass operations for finite sets.
The ordering operations have concrete implementations; subclasses
may override these for speed but should maintain the semantics.
Because <tt class="docutils literal"><span class="pre">Set</span></tt> derives from <tt class="docutils literal"><span class="pre">Sized</span></tt>, <tt class="docutils literal"><span class="pre">__eq__</span></tt> may take a
shortcut and return <tt class="docutils literal"><span class="pre">False</span></tt> immediately if two sets of unequal
length are compared.  Similarly, <tt class="docutils literal"><span class="pre">__le__</span></tt> may return <tt class="docutils literal"><span class="pre">False</span></tt>
immediately if the first set has more members than the second set.
Note that set inclusion implements only a partial ordering;
e.g. <tt class="docutils literal"><span class="pre">{1,</span> <span class="pre">2}</span></tt> and <tt class="docutils literal"><span class="pre">{1,</span> <span class="pre">3}</span></tt> are not ordered (all three of
<tt class="docutils literal"><span class="pre">&lt;</span></tt>, <tt class="docutils literal"><span class="pre">==</span></tt> and <tt class="docutils literal"><span class="pre">&gt;</span></tt> return <tt class="docutils literal"><span class="pre">False</span></tt> for these arguments).
Sets cannot be ordered relative to mappings or sequences, but they
can be compared to those for equality (and then they always
compare unequal).</p>
<p>This class also defines concrete operators to compute union,
intersection, symmetric and asymmetric difference, respectively
<tt class="docutils literal"><span class="pre">__or__</span></tt>, <tt class="docutils literal"><span class="pre">__and__</span></tt>, <tt class="docutils literal"><span class="pre">__xor__</span></tt> and <tt class="docutils literal"><span class="pre">__sub__</span></tt>.  These
operators should return instances of <tt class="docutils literal"><span class="pre">Set</span></tt>.  The default
implementations call the overridable class method
<tt class="docutils literal"><span class="pre">_from_iterable()</span></tt> with an iterable argument.  This factory
method's default implementation returns a <tt class="docutils literal"><span class="pre">frozenset</span></tt> instance;
it may be overridden to return another appropriate <tt class="docutils literal"><span class="pre">Set</span></tt>
subclass.</p>
<p>Finally, this class defines a concrete method <tt class="docutils literal"><span class="pre">_hash</span></tt> which
computes the hash value from the elements.  Hashable subclasses of
<tt class="docutils literal"><span class="pre">Set</span></tt> can implement <tt class="docutils literal"><span class="pre">__hash__</span></tt> by calling <tt class="docutils literal"><span class="pre">_hash</span></tt> or they
can reimplement the same algorithm more efficiently; but the
algorithm implemented should be the same.  Currently the algorithm
is fully specified only by the source code <a class="footnote-reference" href="#id27" id="id10">[15]</a>.</p>
<p class="last"><strong>Note:</strong> the <tt class="docutils literal"><span class="pre">issubset</span></tt> and <tt class="docutils literal"><span class="pre">issuperset</span></tt> methods found on the
set type in Python 2 are not supported, as these are mostly just
aliases for <tt class="docutils literal"><span class="pre">__le__</span></tt> and <tt class="docutils literal"><span class="pre">__ge__</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">MutableSet</span></tt></dt>
<dd><p class="first">This is a subclass of <tt class="docutils literal"><span class="pre">Set</span></tt> implementing additional operations
to add and remove elements.  The supported methods have the
semantics known from the <tt class="docutils literal"><span class="pre">set</span></tt> type in Python 2 (except for
<tt class="docutils literal"><span class="pre">discard</span></tt>, which is modeled after Java):</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">.add(x)</span></tt></dt>
<dd>Abstract method returning a <tt class="docutils literal"><span class="pre">bool</span></tt> that adds the element
<tt class="docutils literal"><span class="pre">x</span></tt> if it isn't already in the set.  It should return
<tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> was added, <tt class="docutils literal"><span class="pre">False</span></tt> if it was already
there. The abstract implementation raises
<tt class="docutils literal"><span class="pre">NotImplementedError</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">.discard(x)</span></tt></dt>
<dd>Abstract method returning a <tt class="docutils literal"><span class="pre">bool</span></tt> that removes the element
<tt class="docutils literal"><span class="pre">x</span></tt> if present.  It should return <tt class="docutils literal"><span class="pre">True</span></tt> if the element
was present and <tt class="docutils literal"><span class="pre">False</span></tt> if it wasn't.  The abstract
implementation raises <tt class="docutils literal"><span class="pre">NotImplementedError</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">.pop()</span></tt></dt>
<dd>Concrete method that removes and returns an arbitrary item.
If the set is empty, it raises <tt class="docutils literal"><span class="pre">KeyError</span></tt>.  The default
implementation removes the first item returned by the set's
iterator.</dd>
<dt><tt class="docutils literal"><span class="pre">.toggle(x)</span></tt></dt>
<dd>Concrete method returning a <tt class="docutils literal"><span class="pre">bool</span></tt> that adds x to the set if
it wasn't there, but removes it if it was there.  It should
return <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">x</span></tt> was added, <tt class="docutils literal"><span class="pre">False</span></tt> if it was
removed.</dd>
<dt><tt class="docutils literal"><span class="pre">.clear()</span></tt></dt>
<dd>Concrete method that empties the set.  The default
implementation repeatedly calls <tt class="docutils literal"><span class="pre">self.pop()</span></tt> until
<tt class="docutils literal"><span class="pre">KeyError</span></tt> is caught.  (<strong>Note:</strong> this is likely much slower
than simply creating a new set, even if an implementation
overrides it with a faster approach; but in some cases object
identity is important.)</dd>
</dl>
<p class="last">This also supports the in-place mutating operations <tt class="docutils literal"><span class="pre">|=</span></tt>,
<tt class="docutils literal"><span class="pre">&amp;=</span></tt>, <tt class="docutils literal"><span class="pre">^=</span></tt>, <tt class="docutils literal"><span class="pre">-=</span></tt>.  These are concrete methods whose right
operand can be an arbitrary <tt class="docutils literal"><span class="pre">Iterable</span></tt>, except for <tt class="docutils literal"><span class="pre">&amp;=</span></tt>, whose
right operand must be a <tt class="docutils literal"><span class="pre">Container</span></tt>.  This ABC does not provide
the named methods present on the built-in concrete <tt class="docutils literal"><span class="pre">set</span></tt> type
that perform (almost) the same operations.</p>
</dd>
</dl>
</div>
<div class="section" id="mappings">
<h3><a class="toc-backref" href="#id38">Mappings</a></h3>
<p>These abstract classes represent read-only mappings and mutable
mappings.  The <tt class="docutils literal"><span class="pre">Mapping</span></tt> class represents the most common read-only
mapping API.</p>
<p>The built-in type <tt class="docutils literal"><span class="pre">dict</span></tt> derives from <tt class="docutils literal"><span class="pre">MutableMapping</span></tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Mapping</span></tt></dt>
<dd><p class="first">A subclass of <tt class="docutils literal"><span class="pre">Container</span></tt>, <tt class="docutils literal"><span class="pre">Iterable</span></tt> and <tt class="docutils literal"><span class="pre">Sized</span></tt>.  The keys
of a mapping naturally form a set.  The (key, value) pairs (which
must be tuples) are also referred to as items.  The items also
form a set.  Methods:</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">.__getitem__(key)</span></tt></dt>
<dd>Abstract method that returns the value corresponding to
<tt class="docutils literal"><span class="pre">key</span></tt>, or raises <tt class="docutils literal"><span class="pre">KeyError</span></tt>.  The implementation always
raises <tt class="docutils literal"><span class="pre">KeyError</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">.get(key,</span> <span class="pre">default=None)</span></tt></dt>
<dd>Concrete method returning <tt class="docutils literal"><span class="pre">self[key]</span></tt> if this does not raise
<tt class="docutils literal"><span class="pre">KeyError</span></tt>, and the <tt class="docutils literal"><span class="pre">default</span></tt> value if it does.</dd>
<dt><tt class="docutils literal"><span class="pre">.__contains__(key)</span></tt></dt>
<dd>Concrete method returning <tt class="docutils literal"><span class="pre">True</span></tt> if <tt class="docutils literal"><span class="pre">self[key]</span></tt> does not
raise <tt class="docutils literal"><span class="pre">KeyError</span></tt>, and <tt class="docutils literal"><span class="pre">False</span></tt> if it does.</dd>
<dt><tt class="docutils literal"><span class="pre">.__len__()</span></tt></dt>
<dd>Abstract method returning the number of distinct keys (i.e.,
the length of the key set).</dd>
<dt><tt class="docutils literal"><span class="pre">.__iter__()</span></tt></dt>
<dd>Abstract method returning each key in the key set exactly once.</dd>
<dt><tt class="docutils literal"><span class="pre">.keys()</span></tt></dt>
<dd>Concrete method returning the key set as a <tt class="docutils literal"><span class="pre">Set</span></tt>.  The
default concrete implementation returns a &quot;view&quot; on the key
set (meaning if the underlying mapping is modified, the view's
value changes correspondingly); subclasses are not required to
return a view but they should return a <tt class="docutils literal"><span class="pre">Set</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">.items()</span></tt></dt>
<dd>Concrete method returning the items as a <tt class="docutils literal"><span class="pre">Set</span></tt>.  The default
concrete implementation returns a &quot;view&quot; on the item set;
subclasses are not required to return a view but they should
return a <tt class="docutils literal"><span class="pre">Set</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">.values()</span></tt></dt>
<dd>Concrete method returning the values as a sized, iterable
container (not a set!).  The default concrete implementation
returns a &quot;view&quot; on the values of the mapping; subclasses are
not required to return a view but they should return a sized,
iterable container.</dd>
</dl>
<p>The following invariants should hold for any mapping <tt class="docutils literal"><span class="pre">m</span></tt>:</p>
<pre class="literal-block">
len(m.values()) == len(m.keys()) == len(m.items()) == len(m)
[value for value in m.values()] == [m[key] for key in m.keys()]
[item for item in m.items()] == [(key, m[key]) for key in m.keys()]
</pre>
<p class="last">i.e. iterating over the items, keys and values should return
results in the same order.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">MutableMapping</span></tt></dt>
<dd>A subclass of <tt class="docutils literal"><span class="pre">Mapping</span></tt> that also implements some standard
mutating methods.  Abstract methods include <tt class="docutils literal"><span class="pre">__setitem__</span></tt>,
<tt class="docutils literal"><span class="pre">__delitem__</span></tt>.  Concrete methods include <tt class="docutils literal"><span class="pre">pop</span></tt>, <tt class="docutils literal"><span class="pre">popitem</span></tt>,
<tt class="docutils literal"><span class="pre">clear</span></tt>, <tt class="docutils literal"><span class="pre">update</span></tt>.  <strong>Note:</strong> <tt class="docutils literal"><span class="pre">setdefault</span></tt> is <em>not</em> included.
<strong>Open issues:</strong> Write out the specs for the methods.</dd>
</dl>
</div>
<div class="section" id="sequences">
<h3><a class="toc-backref" href="#id39">Sequences</a></h3>
<p>These abstract classes represent read-only sequences and mutable
sequences.</p>
<p>The built-in <tt class="docutils literal"><span class="pre">list</span></tt> and <tt class="docutils literal"><span class="pre">bytes</span></tt> types derive from
<tt class="docutils literal"><span class="pre">MutableSequence</span></tt>.  The built-in <tt class="docutils literal"><span class="pre">tuple</span></tt> and <tt class="docutils literal"><span class="pre">str</span></tt> types derive
from <tt class="docutils literal"><span class="pre">Sequence</span></tt> and <tt class="docutils literal"><span class="pre">Hashable</span></tt>.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">Sequence</span></tt></dt>
<dd><p class="first">A subclass of <tt class="docutils literal"><span class="pre">Iterable</span></tt>, <tt class="docutils literal"><span class="pre">Sized</span></tt>, <tt class="docutils literal"><span class="pre">Container</span></tt>.  It
defines a new abstract method <tt class="docutils literal"><span class="pre">__getitem__</span></tt> that has a somewhat
complicated signature: when called with an integer, it returns an
element of the sequence or raises <tt class="docutils literal"><span class="pre">IndexError</span></tt>; when called with
a <tt class="docutils literal"><span class="pre">slice</span></tt> object, it returns another <tt class="docutils literal"><span class="pre">Sequence</span></tt>.  The concrete
<tt class="docutils literal"><span class="pre">__iter__</span></tt> method iterates over the elements using
<tt class="docutils literal"><span class="pre">__getitem__</span></tt> with integer arguments 0, 1, and so on, until
<tt class="docutils literal"><span class="pre">IndexError</span></tt> is raised.  The length should be equal to the
number of values returned by the iterator.</p>
<p class="last"><strong>Open issues:</strong> Other candidate methods, which can all have
default concrete implementations that only depend on <tt class="docutils literal"><span class="pre">__len__</span></tt>
and <tt class="docutils literal"><span class="pre">__getitem__</span></tt> with an integer argument: <tt class="docutils literal"><span class="pre">__reversed__</span></tt>,
<tt class="docutils literal"><span class="pre">index</span></tt>, <tt class="docutils literal"><span class="pre">count</span></tt>, <tt class="docutils literal"><span class="pre">__add__</span></tt>, <tt class="docutils literal"><span class="pre">__mul__</span></tt>.</p>
</dd>
<dt><tt class="docutils literal"><span class="pre">MutableSequence</span></tt></dt>
<dd>A subclass of <tt class="docutils literal"><span class="pre">Sequence</span></tt> adding some standard mutating methods.
Abstract mutating methods: <tt class="docutils literal"><span class="pre">__setitem__</span></tt> (for integer indices as
well as slices), <tt class="docutils literal"><span class="pre">__delitem__</span></tt> (ditto), <tt class="docutils literal"><span class="pre">insert</span></tt>.  Concrete
mutating methods: <tt class="docutils literal"><span class="pre">append</span></tt>, <tt class="docutils literal"><span class="pre">reverse</span></tt>, <tt class="docutils literal"><span class="pre">extend</span></tt>, <tt class="docutils literal"><span class="pre">pop</span></tt>,
<tt class="docutils literal"><span class="pre">remove</span></tt>.  Concrete mutating operators: <tt class="docutils literal"><span class="pre">+=</span></tt>, <tt class="docutils literal"><span class="pre">*=</span></tt> (these
mutate the object in place).  <strong>Note:</strong> this does not define
<tt class="docutils literal"><span class="pre">sort()</span></tt> -- that is only required to exist on genuine <tt class="docutils literal"><span class="pre">list</span></tt>
instances.</dd>
</dl>
</div>
</div>
<div class="section" id="strings">
<h2><a class="toc-backref" href="#id40">Strings</a></h2>
<p>Python 3000 will likely have at least two built-in string types: byte
strings (<tt class="docutils literal"><span class="pre">bytes</span></tt>), deriving from <tt class="docutils literal"><span class="pre">MutableSequence</span></tt>, and (Unicode)
character strings (<tt class="docutils literal"><span class="pre">str</span></tt>), deriving from <tt class="docutils literal"><span class="pre">Sequence</span></tt> and
<tt class="docutils literal"><span class="pre">Hashable</span></tt>.</p>
<p><strong>Open issues:</strong> define the base interfaces for these so alternative
implementations and subclasses know what they are in for.  This may be
the subject of a new PEP or PEPs (<a class="reference external" href="/dev/peps/pep-0358">PEP 358</a> should be co-opted for the
<tt class="docutils literal"><span class="pre">bytes</span></tt> type).</p>
</div>
</div>
<div class="section" id="abcs-vs-alternatives">
<h1><a class="toc-backref" href="#id41">ABCs vs. Alternatives</a></h1>
<p>In this section I will attempt to compare and contrast ABCs to other
approaches that have been proposed.</p>
<div class="section" id="abcs-vs-duck-typing">
<h2><a class="toc-backref" href="#id42">ABCs vs. Duck Typing</a></h2>
<p>Does the introduction of ABCs mean the end of Duck Typing?  I don't
think so.  Python will not require that a class derives from
<tt class="docutils literal"><span class="pre">BasicMapping</span></tt> or <tt class="docutils literal"><span class="pre">Sequence</span></tt> when it defines a <tt class="docutils literal"><span class="pre">__getitem__</span></tt>
method, nor will the <tt class="docutils literal"><span class="pre">x[y]</span></tt> syntax require that <tt class="docutils literal"><span class="pre">x</span></tt> is an instance
of either ABC.  You will still be able to assign any &quot;file-like&quot;
object to <tt class="docutils literal"><span class="pre">sys.stdout</span></tt>, as long as it has a <tt class="docutils literal"><span class="pre">write</span></tt> method.</p>
<p>Of course, there will be some carrots to encourage users to derive
from the appropriate base classes; these vary from default
implementations for certain functionality to an improved ability to
distinguish between mappings and sequences.  But there are no sticks.
If <tt class="docutils literal"><span class="pre">hasattr(x,</span> <span class="pre">&quot;__len__&quot;)</span></tt> works for you, great!  ABCs are intended to
solve problems that don't have a good solution at all in Python 2,
such as distinguishing between mappings and sequences.</p>
</div>
<div class="section" id="abcs-vs-generic-functions">
<h2><a class="toc-backref" href="#id43">ABCs vs. Generic Functions</a></h2>
<p>ABCs are compatible with Generic Functions (GFs).  For example, my own
Generic Functions implementation <a class="footnote-reference" href="#id16" id="id11">[4]</a> uses the classes (types) of the
arguments as the dispatch key, allowing derived classes to override
base classes.  Since (from Python's perspective) ABCs are quite
ordinary classes, using an ABC in the default implementation for a GF
can be quite appropriate.  For example, if I have an overloaded
<tt class="docutils literal"><span class="pre">prettyprint</span></tt> function, it would make total sense to define
pretty-printing of sets like this:</p>
<pre class="literal-block">
&#64;prettyprint.register(Set)
def pp_set(s):
    return &quot;{&quot; + ... + &quot;}&quot;  # Details left as an exercise
</pre>
<p>and implementations for specific subclasses of Set could be added
easily.</p>
<p>I believe ABCs also won't present any problems for RuleDispatch,
Phillip Eby's GF implementation in PEAK <a class="footnote-reference" href="#id17" id="id12">[5]</a>.</p>
<p>Of course, GF proponents might claim that GFs (and concrete, or
implementation, classes) are all you need.  But even they will not
deny the usefulness of inheritance; and one can easily consider the
ABCs proposed in this PEP as optional implementation base classes;
there is no requirement that all user-defined mappings derive from
<tt class="docutils literal"><span class="pre">BasicMapping</span></tt>.</p>
</div>
<div class="section" id="abcs-vs-interfaces">
<h2><a class="toc-backref" href="#id44">ABCs vs. Interfaces</a></h2>
<p>ABCs are not intrinsically incompatible with Interfaces, but there is
considerable overlap.  For now, I'll leave it to proponents of
Interfaces to explain why Interfaces are better.  I expect that much
of the work that went into e.g. defining the various shades of
&quot;mapping-ness&quot; and the nomenclature could easily be adapted for a
proposal to use Interfaces instead of ABCs.</p>
<p>&quot;Interfaces&quot; in this context refers to a set of proposals for
additional metadata elements attached to a class which are not part of
the regular class hierarchy, but do allow for certain types of
inheritance testing.</p>
<p>Such metadata would be designed, at least in some proposals, so as to
be easily mutable by an application, allowing application writers to
override the normal classification of an object.</p>
<p>The drawback to this idea of attaching mutable metadata to a class is
that classes are shared state, and mutating them may lead to conflicts
of intent.  Additionally, the need to override the classification of
an object can be done more cleanly using generic functions: In the
simplest case, one can define a &quot;category membership&quot; generic function
that simply returns False in the base implementation, and then provide
overrides that return True for any classes of interest.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id45">References</a></h1>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>An Introduction to ABC's, by Talin
(<a class="reference external" href="http://mail.python.org/pipermail/python-3000/2007-April/006614.html">http://mail.python.org/pipermail/python-3000/2007-April/006614.html</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>Incomplete implementation prototype, by GvR
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/abc/">http://svn.python.org/view/sandbox/trunk/abc/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td>Possible Python 3K Class Tree?, wiki page created by Bill Janssen
(<a class="reference external" href="http://wiki.python.org/moin/AbstractBaseClasses">http://wiki.python.org/moin/AbstractBaseClasses</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[4]</a></td><td>Generic Functions implementation, by GvR
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/overload/">http://svn.python.org/view/sandbox/trunk/overload/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[5]</a></td><td>Charming Python: Scaling a new PEAK, by David Mertz
(<a class="reference external" href="http://www-128.ibm.com/developerworks/library/l-cppeak2/">http://www-128.ibm.com/developerworks/library/l-cppeak2/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[6]</a></td><td>Implementation of &#64;abstractmethod
(<a class="reference external" href="http://python.org/sf/1706989">http://python.org/sf/1706989</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[7]</a></td><td>Unifying types and classes in Python 2.2, by GvR
(<a class="reference external" href="http://www.python.org/download/releases/2.2.3/descrintro/">http://www.python.org/download/releases/2.2.3/descrintro/</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[8]</a></td><td>Putting Metaclasses to Work: A New Dimension in Object-Oriented
Programming, by Ira R. Forman and Scott H. Danforth
(<a class="reference external" href="http://www.amazon.com/gp/product/0201433052">http://www.amazon.com/gp/product/0201433052</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[9]</td><td>Partial order, in Wikipedia
(<a class="reference external" href="http://en.wikipedia.org/wiki/Partial_order">http://en.wikipedia.org/wiki/Partial_order</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[10]</td><td>Total order, in Wikipedia
(<a class="reference external" href="http://en.wikipedia.org/wiki/Total_order">http://en.wikipedia.org/wiki/Total_order</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[11]</a></td><td>Finite set, in Wikipedia
(<a class="reference external" href="http://en.wikipedia.org/wiki/Finite_set">http://en.wikipedia.org/wiki/Finite_set</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[12]</a></td><td>Make isinstance/issubclass overloadable
(<a class="reference external" href="http://python.org/sf/1708353">http://python.org/sf/1708353</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[13]</a></td><td>ABCMeta sample implementation
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/abc/xyz.py">http://svn.python.org/view/sandbox/trunk/abc/xyz.py</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[14]</a></td><td>python-dev email (&quot;Comparing heterogeneous types&quot;)
<a class="reference external" href="http://mail.python.org/pipermail/python-dev/2004-June/045111.html">http://mail.python.org/pipermail/python-dev/2004-June/045111.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[15]</a></td><td>Function <tt class="docutils literal"><span class="pre">frozenset_hash()</span></tt> in Object/setobject.c
(<a class="reference external" href="http://svn.python.org/view/python/trunk/Objects/setobject.c">http://svn.python.org/view/python/trunk/Objects/setobject.c</a>)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id28" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[16]</a></td><td>Multiple interpreters in mod_python
(<a class="reference external" href="http://www.modpython.org/live/current/doc-html/pyapi-interps.html">http://www.modpython.org/live/current/doc-html/pyapi-interps.html</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id46">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="pep-3119.txt">View document source</a>.
Generated on: 2013-09-17 06:14 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
