<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 3130 -- Access to Current Module/Class/Function</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">

<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>3130</td></tr>
  <tr><th>Title:&nbsp;</th><td>Access to Current Module/Class/Function</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision: 55236 $</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="http://svn.python.org/view/peps/trunk/pep-3130.txt">$Date: 2007-05-10 15:56:48 -0700 (Thu, 10 May 2007) $</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Jim J. Jewett &lt;jimjjewett&#32;&#97;t&#32;gmail.com&gt;</td></tr>
  <tr><th>Status:&nbsp;</th><td>Rejected</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Content-Type:&nbsp;</th><td><a href="pep-0009.html">text/plain</a> </td></tr>
  <tr><th>Created:&nbsp;</th><td>22-Apr-2007</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>3.0</td></tr>
  <tr><th>Post-History:&nbsp;</th><td>22-Apr-2007</td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Rejection Notice</h3>
<pre>
    This PEP is rejected.  It is not clear how it should be
    implemented or what the precise semantics should be in edge cases,
    and there aren't enough important use cases given.  response has
    been lukewarm at best.


</pre>
<h3>Abstract</h3>
<pre>
    It is common to need a reference to the current module, class,
    or function, but there is currently no entirely correct way to
    do this.  This PEP proposes adding the keywords __module__,
    __class__, and __function__.


</pre>
<h3>Rationale for __module__</h3>
<pre>
    Many modules export various functions, classes, and other objects,
    but will perform additional activities (such as running unit
    tests) when run as a script.  The current idiom is to test whether
    the module's name has been set to magic value.

        if __name__ == "__main__": ...

    More complicated introspection requires a module to (attempt to)
    import itself.  If importing the expected name actually produces
    a different module, there is no good workaround.

        # __import__ lets you use a variable, but... it gets more
        # complicated if the module is in a package.
        __import__(__name__)

        # So just go to sys modules... and hope that the module wasn't
        # hidden/removed (perhaps for security), that __name__ wasn't
        # changed, and definitely hope that no other module with the
        # same name is now available.
        class X(object):
            pass

        import sys
        mod = sys.modules[__name__]
        mod = sys.modules[X.__class__.__module__]

    Proposal:  Add a __module__ keyword which refers to the module
    currently being defined (executed).  (But see open issues.)

        # XXX sys.main is still changing as draft progresses.  May
        # really need sys.modules[sys.main]
        if __module__ is sys.main:    # assumes PEP (3122), Cannon
            ...


</pre>
<h3>Rationale for __class__</h3>
<pre>
    Class methods are passed the current instance; from this they can
    determine self.__class__ (or cls, for class methods).
    Unfortunately, this reference is to the object's actual class,
    which may be a subclass of the defining class.  The current
    workaround is to repeat the name of the class, and assume that the
    name will not be rebound.

        class C(B):

            def meth(self):
                super(C, self).meth() # Hope C is never rebound.

        class D(C):

            def meth(self):
                # ?!? issubclass(D,C), so it "works":
                super(C, self).meth() 

    Proposal: Add a __class__ keyword which refers to the class
    currently being defined (executed).  (But see open issues.)

        class C(B):
            def meth(self):
                super(__class__, self).meth()

    Note that super calls may be further simplified by the "New Super"
    PEP (Spealman).  The __class__ (or __this_class__) attribute came
    up in attempts to simplify the explanation and/or implementation
    of that PEP, but was separated out as an independent decision.

    Note that __class__ (or __this_class__) is not quite the same as
    the __thisclass__ property on bound super objects.  The existing
    super.__thisclass__ property refers to the class from which the
    Method Resolution Order search begins.  In the above class D, it
    would refer to (the current reference of name) C.


</pre>
<h3>Rationale for __function__</h3>
<pre>
    Functions (including methods) often want access to themselves,
    usually for a private storage location or true recursion.  While
    there are several workarounds, all have their drawbacks.

        def counter(_total=[0]):
            # _total shouldn't really appear in the
            # signature at all; the list wrapping and
            # [0] unwrapping obscure the code
            _total[0] += 1
            return _total[0]

        @annotate(total=0)
        def counter():
            # Assume name counter is never rebound:
            counter.total += 1
            return counter.total

        # class exists only to provide storage:
        class _wrap(object):

            __total = 0

            def f(self):
                self.__total += 1
                return self.__total

        # set module attribute to a bound method:
        accum = _wrap().f

        # This function calls "factorial", which should be itself --
        # but the same programming styles that use heavy recursion
        # often have a greater willingness to rebind function names.
        def factorial(n):
            return (n * factorial(n-1) if n else 1)

    Proposal: Add a __function__ keyword which refers to the function
    (or method) currently being defined (executed).  (But see open
    issues.)

        @annotate(total=0)
        def counter():
            # Always refers to this function obj:
            __function__.total += 1
            return __function__.total

        def factorial(n):
            return (n * __function__(n-1) if n else 1)


</pre>
<h3>Backwards Compatibility</h3>
<pre>
    While a user could be using these names already, double-underscore
    names ( __anything__ ) are explicitly reserved to the interpreter.
    It is therefore acceptable to introduce special meaning to these
    names within a single feature release.


</pre>
<h3>Implementation</h3>
<pre>
    Ideally, these names would be keywords treated specially by the
    bytecode compiler.

    Guido has suggested [1] using a cell variable filled in by the
    metaclass.

    Michele Simionato has provided a prototype using bytecode hacks
    [2].  This does not require any new bytecode operators; it just
    modifies the which specific sequence of existing operators gets
    run.


</pre>
<h3>Open Issues</h3>
<pre>
    - Are __module__, __class__, and __function__ the right names?  In
      particular, should the names include the word "this", either as
      __this_module__, __this_class__, and __this_function__, (format
      discussed on the python-3000 and python-ideas lists) or as
      __thismodule__, __thisclass__, and __thisfunction__ (inspired
      by, but conflicting with, current usage of super.__thisclass__).

    - Are all three keywords needed, or should this enhancement be
      limited to a subset of the objects?  Should methods be treated
      separately from other functions?


</pre>
<h3>References</h3>
<pre>
    [1] Fixing super anyone?  Guido van Rossum
        <a href="http://mail.python.org/pipermail/python-3000/2007-April/006671.html">http://mail.python.org/pipermail/python-3000/2007-April/006671.html</a>

    [2] Descriptor/Decorator challenge,  Michele Simionato
        <a href="http://groups.google.com/group/comp.lang.python/browse_frm/thread/a6010c7494871bb1/62a2da68961caeb6?lnk=gst&amp;q=simionato+challenge&amp;rnum=1&amp;hl=en#62a2da68961caeb6">http://groups.google.com/group/comp.lang.python/browse_frm/thread/a6010c7494871bb1/62a2da68961caeb6?lnk=gst&amp;q=simionato+challenge&amp;rnum=1&amp;hl=en#62a2da68961caeb6</a>


</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.


</pre>
</div>
</body>
</html>
