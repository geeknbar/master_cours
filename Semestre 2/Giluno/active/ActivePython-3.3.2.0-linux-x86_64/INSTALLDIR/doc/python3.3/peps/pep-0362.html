<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
  <title>PEP 362 -- Function Signature Object</title>
  <link rel="stylesheet" href="pep.css" type="text/css" /></head>
<body bgcolor="white">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">362</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Function Signature Object</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">59031</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-0362.txt">2007-11-16 20:20:22 -0800 (Fri, 16 Nov 2007)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Brett Cannon &lt;brett&#32;&#97;t&#32;python.org&gt;
Jiwon Seo &lt;seojiwon&#32;&#97;t&#32;gmail.com&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">21-Aug-2006</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.6</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">05-Sep-2007</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id2">Abstract</a></li>
<li><a class="reference internal" href="#purpose" id="id3">Purpose</a></li>
<li><a class="reference internal" href="#signature-object" id="id4">Signature Object</a></li>
<li><a class="reference internal" href="#parameter-object" id="id5">Parameter Object</a></li>
<li><a class="reference internal" href="#implementation" id="id6">Implementation</a></li>
<li><a class="reference internal" href="#examples" id="id7">Examples</a><ul>
<li><a class="reference internal" href="#annotation-checker" id="id8">Annotation Checker</a></li>
</ul>
</li>
<li><a class="reference internal" href="#open-issues" id="id9">Open Issues</a><ul>
<li><a class="reference internal" href="#when-to-construct-the-signature-object" id="id10">When to construct the Signature object?</a></li>
<li><a class="reference internal" href="#should-signature-bind-return-parameter-objects-as-keys" id="id11">Should <tt class="docutils literal"><span class="pre">Signature.bind</span></tt> return Parameter objects as keys?</a></li>
<li><a class="reference internal" href="#have-var-args-and-var-kw-args-default-to-none" id="id12">Have <tt class="docutils literal"><span class="pre">var_args</span></tt> and <tt class="docutils literal"><span class="pre">_var_kw_args</span></tt> default to <tt class="docutils literal"><span class="pre">None</span></tt>?</a></li>
<li><a class="reference internal" href="#deprecate-inspect-getargspec-and-formatargspec" id="id13">Deprecate <tt class="docutils literal"><span class="pre">inspect.getargspec()</span></tt> and <tt class="docutils literal"><span class="pre">.formatargspec()</span></tt>?</a></li>
<li><a class="reference internal" href="#have-the-objects-be-live" id="id14">Have the objects be &quot;live&quot;?</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references" id="id15">References</a></li>
<li><a class="reference internal" href="#copyright" id="id16">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id2">Abstract</a></h1>
<p>Python has always supported powerful introspection capabilities,
including that for functions and methods (for the rest of this PEP the
word &quot;function&quot; refers to both functions and methods).  Taking a
function object, you can fully reconstruct the function's signature.
Unfortunately it is a little unruly having to look at all the
different attributes to pull together complete information for a
function's signature.</p>
<p>This PEP proposes an object representation for function signatures.
This should help facilitate introspection on functions for various
uses.  The introspection information contains all possible information
about the parameters in a signature (including Python 3.0 features).</p>
<p>This object, though, is not meant to replace existing ways of
introspection on a function's signature.  The current solutions are
there to make Python's execution work in an efficient manner.  The
proposed object representation is only meant to help make application
code have an easier time to query a function on its signature.</p>
</div>
<div class="section" id="purpose">
<h1><a class="toc-backref" href="#id3">Purpose</a></h1>
<p>An object representation of a function's call signature should provide
an easy way to introspect what a function expects as arguments.  It
does not need to be a &quot;live&quot; representation, though; the signature can
be inferred once and stored without changes to the signature object
representation affecting the function it represents (but this is an
<a class="reference internal" href="#open-issues">Open Issues</a>).</p>
<p>Indirecation of signature introspection can also occur.  If a
decorator took a decorated function's signature object and set it on
the decorating function then introspection could be redirected to what
is actually expected instead of the typical <tt class="docutils literal"><span class="pre">*args,</span> <span class="pre">**kwargs</span></tt>
signature of decorating functions.</p>
</div>
<div class="section" id="signature-object">
<h1><a class="toc-backref" href="#id4">Signature Object</a></h1>
<p>The overall signature of an object is represented by the Signature
object.  This object is to store a <a class="reference internal" href="#parameter-object">Parameter object</a> for each
parameter in the signature.  It is also to store any information
about the function itself that is pertinent to the signature.</p>
<p>A Signature object has the following structure attributes:</p>
<ul>
<li><dl class="first docutils">
<dt>name <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the function.  This is not fully qualified because
function objects for methods do not know the class they are
contained within.  This makes functions and methods
indistinguishable from one another when passed to decorators,
preventing proper creation of a fully qualified name.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>var_args <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the variable positional parameter (i.e., <tt class="docutils literal"><span class="pre">*args</span></tt>), if
present, or the empty string.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>var_kw_args <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of the variable keyword parameter (i.e., <tt class="docutils literal"><span class="pre">**kwargs</span></tt>), if
present, or the empty string.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>var_annotations: dict(str, object)</dt>
<dd><p class="first last">Dict that contains the annotations for the variable parameters.
The keys are of the variable parameter with values of the
annotation.  If an annotation does not exist for a variable
parameter then the key does not exist in the dict.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>return_annotation <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">If present, the attribute is set to the annotation for the return
type of the function.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>parameters <span class="classifier-delimiter">:</span> <span class="classifier">list(Parameter)</span></dt>
<dd><p class="first last">List of the parameters of the function as represented by
Parameter objects in the order of its definition (keyword-only
arguments are in the order listed by <tt class="docutils literal"><span class="pre">code.co_varnames</span></tt>).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>bind(*args, **kwargs) -&gt; dict(str, object)</dt>
<dd><p class="first last">Create a mapping from arguments to parameters.  The keys are the
names of the parameter that an argument maps to with the value
being the value the parameter would have if this function was
called with the given arguments.</p>
</dd>
</dl>
</li>
</ul>
<p>Signature objects also have the following methods:</p>
<ul>
<li><dl class="first docutils">
<dt>__getitem__(self, key <span class="classifier-delimiter">:</span> <span class="classifier">str) -&gt; Parameter</span></dt>
<dd><p class="first last">Returns the Parameter object for the named parameter.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>__iter__(self)</dt>
<dd><p class="first last">Returns an iterator that returns Parameter objects in their
sequential order based on their 'position' attribute.</p>
</dd>
</dl>
</li>
</ul>
<p>The Signature object is stored in the <tt class="docutils literal"><span class="pre">__signature__</span></tt> attribute of
a function.  When it is to be created is discussed in
<a class="reference internal" href="#open-issues">Open Issues</a>.</p>
</div>
<div class="section" id="parameter-object">
<h1><a class="toc-backref" href="#id5">Parameter Object</a></h1>
<p>A function's signature is made up of several parameters.  Python's
different kinds of parameters is quite large and rich and continues to
grow.  Parameter objects represent any possible parameter.</p>
<p>Originally the plan was to represent parameters using a list of
parameter names on the Signature object along with various dicts keyed
on parameter names to disseminate the various pieces of information
one can know about a parameter.  But the decision was made to
incorporate all information about a parameter in a single object so
as to make extending the information easier.  This was originally put
forth by Talin and the preferred form of Guido (as discussed at the
2006 Google Sprint).</p>
<p>The structure of the Parameter object is:</p>
<ul>
<li><dl class="first docutils">
<dt>name <span class="classifier-delimiter">:</span> <span class="classifier">(str | tuple(str))</span></dt>
<dd><p class="first last">The name of the parameter as a string if it is not a tuple.  If
the argument is a tuple then a tuple of strings is used.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>position <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The position of the parameter within the signature of the
function (zero-indexed).  For keyword-only parameters the position
value is arbitrary while not conflicting with positional
parameters.  The suggestion of setting the attribute to None or -1
to represent keyword-only parameters was rejected to prevent
variable type usage and as a possible point of errors,
respectively.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>default_value <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">The default value for the parameter, if present, else the
attribute does not exist.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>keyword_only <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if the parameter is keyword-only, else False.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>annotation</dt>
<dd><p class="first last">Set to the annotation for the parameter.  If <tt class="docutils literal"><span class="pre">has_annotation</span></tt> is
False then the attribute does not exist to prevent accidental use.</p>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="implementation">
<h1><a class="toc-backref" href="#id6">Implementation</a></h1>
<p>An implementation can be found in Python's sandbox <a class="footnote-reference" href="#impl" id="id1">[1]</a>.
There is a function named <tt class="docutils literal"><span class="pre">signature()</span></tt> which
returns the value stored on the <tt class="docutils literal"><span class="pre">__signature__</span></tt> attribute if it
exists, else it creates the Signature object for the
function and sets <tt class="docutils literal"><span class="pre">__signature__</span></tt>.  For methods this is stored
directly on the im_func function object since that is what decorators
work with.</p>
</div>
<div class="section" id="examples">
<h1><a class="toc-backref" href="#id7">Examples</a></h1>
<div class="section" id="annotation-checker">
<h2><a class="toc-backref" href="#id8">Annotation Checker</a></h2>
<pre class="literal-block">
def quack_check(fxn):
    &quot;&quot;&quot;Decorator to verify arguments and return value quack as they should.

    Positional arguments.
    &gt;&gt;&gt; &#64;quack_check
    ... def one_arg(x:int): pass
    ...
    &gt;&gt;&gt; one_arg(42)
    &gt;&gt;&gt; one_arg('a')
    Traceback (most recent call last):
        ...
    TypeError: 'a' does not quack like a &lt;type 'int'&gt;


    *args
    &gt;&gt;&gt; &#64;quack_check
    ... def var_args(*args:int): pass
    ...
    &gt;&gt;&gt; var_args(*[1,2,3])
    &gt;&gt;&gt; var_args(*[1,'b',3])
    Traceback (most recent call last):
        ...
    TypeError: *args contains a a value that does not quack like a &lt;type 'int'&gt;

    **kwargs
    &gt;&gt;&gt; &#64;quack_check
    ... def var_kw_args(**kwargs:int): pass
    ...
    &gt;&gt;&gt; var_kw_args(**{'a': 1})
    &gt;&gt;&gt; var_kw_args(**{'a': 'A'})
    Traceback (most recent call last):
        ...
    TypeError: **kwargs contains a value that does not quack like a &lt;type 'int'&gt;

    Return annotations.
    &gt;&gt;&gt; &#64;quack_check
    ... def returned(x) -&gt; int: return x
    ...
    &gt;&gt;&gt; returned(42)
    42
    &gt;&gt;&gt; returned('a')
    Traceback (most recent call last):
        ...
    TypeError: the return value 'a' does not quack like a &lt;type 'int'&gt;

    &quot;&quot;&quot;
    # Get the signature; only needs to be calculated once.
    sig = Signature(fxn)
    def check(*args, **kwargs):
        # Find out the variable -&gt; value bindings.
        bindings = sig.bind(*args, **kwargs)
        # Check *args for the proper quack.
        try:
            duck = sig.var_annotations[sig.var_args]
        except KeyError:
            pass
        else:
            # Check every value in *args.
            for value in bindings[sig.var_args]:
                if not isinstance(value, duck):
                    raise TypeError(&quot;*%s contains a a value that does not &quot;
                                    &quot;quack like a %r&quot; %
                                    (sig.var_args, duck))
            # Remove it from the bindings so as to not check it again.
            del bindings[sig.var_args]
        # **kwargs.
        try:
            duck = sig.var_annotations[sig.var_kw_args]
        except (KeyError, AttributeError):
            pass
        else:
            # Check every value in **kwargs.
            for value in bindings[sig.var_kw_args].values():
                if not isinstance(value, duck):
                    raise TypeError(&quot;**%s contains a value that does not &quot;
                                    &quot;quack like a %r&quot; %
                                    (sig.var_kw_args, duck))
            # Remove from bindings so as to not check again.
            del bindings[sig.var_kw_args]
        # For each remaining variable ...
        for var, value in bindings.items():
            # See if an annotation was set.
            try:
                duck = sig[var].annotation
            except AttributeError:
                continue
            # Check that the value quacks like it should.
            if not isinstance(value, duck):
                raise TypeError('%r does not quack like a %s' % (value, duck))
        else:
            # All the ducks quack fine; let the call proceed.
            returned = fxn(*args, **kwargs)
            # Check the return value.
            try:
                if not isinstance(returned, sig.return_annotation):
                    raise TypeError('the return value %r does not quack like '
                                    'a %r' % (returned,
                                        sig.return_annotation))
            except AttributeError:
                pass
            return returned
    # Full-featured version would set function metadata.
    return check
</pre>
</div>
</div>
<div class="section" id="open-issues">
<h1><a class="toc-backref" href="#id9">Open Issues</a></h1>
<div class="section" id="when-to-construct-the-signature-object">
<h2><a class="toc-backref" href="#id10">When to construct the Signature object?</a></h2>
<p>The Signature object can either be created in an eager or lazy
fashion.  In the eager situation, the object can be created during
creation of the function object.  In the lazy situation, one would
pass a function object to a function and that would generate the
Signature object and store it to <tt class="docutils literal"><span class="pre">__signature__</span></tt> if
needed, and then return the value of <tt class="docutils literal"><span class="pre">__signature__</span></tt>.</p>
</div>
<div class="section" id="should-signature-bind-return-parameter-objects-as-keys">
<h2><a class="toc-backref" href="#id11">Should <tt class="docutils literal"><span class="pre">Signature.bind</span></tt> return Parameter objects as keys?</a></h2>
<p>Instead of returning a dict with keys consisting of the name of the
parameters, would it be more useful to instead use Parameter
objects?  The name of the argument can easily be retrieved from the
key (and the name would be used as the hash for a Parameter object).</p>
</div>
<div class="section" id="have-var-args-and-var-kw-args-default-to-none">
<h2><a class="toc-backref" href="#id12">Have <tt class="docutils literal"><span class="pre">var_args</span></tt> and <tt class="docutils literal"><span class="pre">_var_kw_args</span></tt> default to <tt class="docutils literal"><span class="pre">None</span></tt>?</a></h2>
<p>It has been suggested by Fred Drake that these two attributes have a
value of <tt class="docutils literal"><span class="pre">None</span></tt> instead of empty strings when they do not exist.
The answer to this question will influence what the defaults are for
other attributes as well.</p>
</div>
<div class="section" id="deprecate-inspect-getargspec-and-formatargspec">
<h2><a class="toc-backref" href="#id13">Deprecate <tt class="docutils literal"><span class="pre">inspect.getargspec()</span></tt> and <tt class="docutils literal"><span class="pre">.formatargspec()</span></tt>?</a></h2>
<p>Since the Signature object replicates the use of <tt class="docutils literal"><span class="pre">getargspec()</span></tt>
from the <tt class="docutils literal"><span class="pre">inspect</span></tt> module it might make sense to deprecate it in
2.6.  <tt class="docutils literal"><span class="pre">formatargspec()</span></tt> could also go if Signature objects gained a
__str__ representation.</p>
<p>Issue with that is types such as <tt class="docutils literal"><span class="pre">int</span></tt>, when used as annotations,
do not lend themselves for output (e.g., <tt class="docutils literal"><span class="pre">&quot;&lt;type</span> <span class="pre">'int'&gt;&quot;</span></tt> is the
string represenation for <tt class="docutils literal"><span class="pre">int</span></tt>).  The repr representation of types
would need to change in order to make this reasonable.</p>
</div>
<div class="section" id="have-the-objects-be-live">
<h2><a class="toc-backref" href="#id14">Have the objects be &quot;live&quot;?</a></h2>
<p>Jim Jewett pointed out that Signature and Parameter objects could be
&quot;live&quot;.  That would mean requesting information would be done on the
fly instead of caching it on the objects.  It would also allow for
mutating the function if the Signature or Parameter objects were
mutated.</p>
</div>
</div>
<div class="section" id="references">
<h1><a class="toc-backref" href="#id15">References</a></h1>
<table class="docutils footnote" frame="void" id="impl" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>pep362 directory in Python's sandbox
(<a class="reference external" href="http://svn.python.org/view/sandbox/trunk/pep362/">http://svn.python.org/view/sandbox/trunk/pep362/</a>)</td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id16">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="pep-0362.txt">View document source</a>.
Generated on: 2013-09-17 06:14 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
