<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
  <title>PEP 335 -- Overloadable Boolean Operators</title>
  <link rel="stylesheet" href="pep.css" type="text/css" /></head>
<body bgcolor="white">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">335</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">Overloadable Boolean Operators</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">1913</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-0335.txt">2004-09-09 07:17:17 -0700 (Thu, 09 Sep 2004)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Gregory Ewing &lt;greg&#32;&#97;t&#32;cosc.canterbury.ac.nz&gt;</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Draft</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">29-Aug-2004</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">2.4</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">05-Sep-2004</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#abstract" id="id4">Abstract</a></li>
<li><a class="reference internal" href="#background" id="id5">Background</a></li>
<li><a class="reference internal" href="#motivation" id="id6">Motivation</a></li>
<li><a class="reference internal" href="#rationale" id="id7">Rationale</a></li>
<li><a class="reference internal" href="#specification" id="id8">Specification</a><ul>
<li><a class="reference internal" href="#special-methods" id="id9">Special Methods</a></li>
<li><a class="reference internal" href="#bytecodes" id="id10">Bytecodes</a></li>
<li><a class="reference internal" href="#type-slots" id="id11">Type Slots</a></li>
<li><a class="reference internal" href="#python-c-api-functions" id="id12">Python/C API Functions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id1" id="id13">References</a></li>
<li><a class="reference internal" href="#copyright" id="id14">Copyright</a></li>
</ul>
</div>
<div class="section" id="abstract">
<h1><a class="toc-backref" href="#id4">Abstract</a></h1>
<p>This PEP proposes an extension to permit objects to define their own
meanings for the boolean operators 'and', 'or' and 'not', and suggests
an efficient strategy for implementation.  A prototype of this
implementation is available for download.</p>
</div>
<div class="section" id="background">
<h1><a class="toc-backref" href="#id5">Background</a></h1>
<p>Python does not currently provide any '__xxx__' special methods
corresponding to the 'and', 'or' and 'not' boolean operators.  In the
case of 'and' and 'or', the most likely reason is that these operators
have short-circuiting semantics, i.e. the second operand is not
evaluated if the result can be determined from the first operand.  The
usual technique of providing special methods for these operators
therefore would not work.</p>
<p>There is no such difficulty in the case of 'not', however, and it
would be straightforward to provide a special method for this
operator.  The rest of this proposal will therefore concentrate mainly
on providing a way to overload 'and' and 'or'.</p>
</div>
<div class="section" id="motivation">
<h1><a class="toc-backref" href="#id6">Motivation</a></h1>
<p>There are many applications in which it is natural to provide custom
meanings for Python operators, and in some of these, having boolean
operators excluded from those able to be customised can be
inconvenient.  Examples include:</p>
<ol class="arabic">
<li><p class="first">Numeric/Numarray, in which almost all the operators are defined on
arrays so as to perform the appropriate operation between
corresponding elements, and return an array of the results.  For
consistency, one would expect a boolean operation between two
arrays to return an array of booleans, but this is not currently
possible.</p>
<p>There is a precedent for an extension of this kind: comparison
operators were originally restricted to returning boolean results,
and rich comparisons were added so that comparisons of Numeric
arrays could return arrays of booleans.</p>
</li>
<li><p class="first">A symbolic algebra system, in which a Python expression is
evaluated in an environment which results in it constructing a tree
of objects corresponding to the structure of the expression.</p>
</li>
<li><p class="first">A relational database interface, in which a Python expression is
used to construct an SQL query.</p>
</li>
</ol>
<p>A workaround often suggested is to use the bitwise operators '&amp;', '|'
and '~' in place of 'and', 'or' and 'not', but this has some
drawbacks.  The precedence of these is different in relation to the
other operators, and they may already be in use for other purposes (as
in example 1).  There is also the aesthetic consideration of forcing
users to use something other than the most obvious syntax for what
they are trying to express.  This would be particularly acute in the
case of example 3, considering that boolean operations are a staple of
SQL queries.</p>
</div>
<div class="section" id="rationale">
<h1><a class="toc-backref" href="#id7">Rationale</a></h1>
<p>The requirements for a successful solution to the problem of allowing
boolean operators to be customised are:</p>
<ol class="arabic simple">
<li>In the default case (where there is no customisation), the existing
short-circuiting semantics must be preserved.</li>
<li>There must not be any appreciable loss of speed in the default
case.</li>
<li>If possible, the customisation mechanism should allow the object to
provide either short-circuiting or non-short-circuiting semantics,
at its discretion.</li>
</ol>
<p>One obvious strategy, that has been previously suggested, is to pass
into the special method the first argument and a function for
evaluating the second argument.  This would satisfy requirements 1 and
3, but not requirement 2, since it would incur the overhead of
constructing a function object and possibly a Python function call on
every boolean operation.  Therefore, it will not be considered further
here.</p>
<p>The following section proposes a strategy that addresses all three
requirements.  A <a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/obo//Python_OBO.tar.gz">prototype implementation</a> <a class="footnote-reference" href="#id2" id="id3">[1]</a> of this strategy is
available for download.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id8">Specification</a></h1>
<div class="section" id="special-methods">
<h2><a class="toc-backref" href="#id9">Special Methods</a></h2>
<p>At the Python level, objects may define the following special methods.</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="30%" />
<col width="43%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Unary</th>
<th class="head">Binary, phase 1</th>
<th class="head">Binary, phase 2</th>
</tr>
</thead>
<tbody valign="top">
<tr><td><ul class="first last simple">
<li>__not__(self)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>__and1__(self)</li>
<li>__or1__(self)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>__and2__(self, other)</li>
<li>__or2__(self, other)</li>
<li>__rand2__(self, other)</li>
<li>__ror2__(self, other)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The __not__ method, if defined, implements the 'not' operator.  If it
is not defined, or it returns NotImplemented, existing semantics are
used.</p>
<p>To permit short-circuiting, processing of the 'and' and 'or' operators
is split into two phases.  Phase 1 occurs after evaluation of the first
operand but before the second.  If the first operand defines the
appropriate phase 1 method, it is called with the first operand as
argument.  If that method can determine the result without needing the
second operand, it returns the result, and further processing is
skipped.</p>
<p>If the phase 1 method determines that the second operand is needed, it
returns the special value NeedOtherOperand.  This triggers the
evaluation of the second operand, and the calling of an appropriate
phase 2 method. During phase 2, the __and2__/__rand2__ and
__or2__/__ror2__ method pairs work as for other binary operators.</p>
<p>Processing falls back to existing semantics if at any stage a relevant
special method is not found or returns NotImplemented.</p>
<p>As a special case, if the first operand defines a phase 2 method but
no corresponding phase 1 method, the second operand is always
evaluated and the phase 2 method called.  This allows an object which
does not want short-circuiting semantics to simply implement the
relevant phase 2 methods and ignore phase 1.</p>
</div>
<div class="section" id="bytecodes">
<h2><a class="toc-backref" href="#id10">Bytecodes</a></h2>
<p>The patch adds four new bytecodes, LOGICAL_AND_1, LOGICAL_AND_2,
LOGICAL_OR_1 and LOGICAL_OR_2.  As an example of their use, the
bytecode generated for an 'and' expression looks like this:</p>
<pre class="literal-block">
     .
     .
     .
     evaluate first operand
     LOGICAL_AND_1  L
     evaluate second operand
     LOGICAL_AND_2
L:   .
     .
     .
</pre>
<p>The LOGICAL_AND_1 bytecode performs phase 1 processing.  If it
determines that the second operand is needed, it leaves the first
operand on the stack and continues with the following code.  Otherwise
it pops the first operand, pushes the result and branches to L.</p>
<p>The LOGICAL_AND_2 bytecode performs phase 2 processing, popping both
operands and pushing the result.</p>
</div>
<div class="section" id="type-slots">
<h2><a class="toc-backref" href="#id11">Type Slots</a></h2>
<p>A the C level, the new special methods are manifested as five new
slots in the type object.  In the patch, they are added to the
tp_as_number substructure, since this allowed making use of some
existing code for dealing with unary and binary operators.  Their
existence is signalled by a new type flag,
Py_TPFLAGS_HAVE_BOOLEAN_OVERLOAD.</p>
<p>The new type slots are:</p>
<pre class="literal-block">
unaryfunc nb_logical_not;
unaryfunc nb_logical_and_1;
unaryfunc nb_logical_or_1;
binaryfunc nb_logical_and_2;
binaryfunc nb_logical_or_2;
</pre>
</div>
<div class="section" id="python-c-api-functions">
<h2><a class="toc-backref" href="#id12">Python/C API Functions</a></h2>
<p>There are also five new Python/C API functions corresponding to the
new operations:</p>
<pre class="literal-block">
PyObject *PyObject_LogicalNot(PyObject *);
PyObject *PyObject_LogicalAnd1(PyObject *);
PyObject *PyObject_LogicalOr1(PyObject *);
PyObject *PyObject_LogicalAnd2(PyObject *, PyObject *);
PyObject *PyObject_LogicalOr2(PyObject *, PyObject *);
</pre>
</div>
</div>
<div class="section" id="id1">
<h1><a class="toc-backref" href="#id13">References</a></h1>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[1]</a></td><td><a class="reference external" href="http://www.cosc.canterbury.ac.nz/~greg/python/obo//Python_OBO.tar.gz">http://www.cosc.canterbury.ac.nz/~greg/python/obo//Python_OBO.tar.gz</a></td></tr>
</tbody>
</table>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id14">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>

</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="pep-0335.txt">View document source</a>.
Generated on: 2013-09-17 06:13 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
