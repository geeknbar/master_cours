<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
  <title>PEP 3116 -- New I/O</title>
  <link rel="stylesheet" href="pep.css" type="text/css" /></head>
<body bgcolor="white">
<table class="rfc2822 docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">PEP:</th><td class="field-body">3116</td>
</tr>
<tr class="field"><th class="field-name">Title:</th><td class="field-body">New I/O</td>
</tr>
<tr class="field"><th class="field-name">Version:</th><td class="field-body">62228</td>
</tr>
<tr class="field"><th class="field-name">Last-Modified:</th><td class="field-body"><a class="reference external" href="http://svn.python.org/view/*checkout*/peps/trunk/pep-3116.txt">2008-04-08 14:24:20 -0700 (Tue, 08 Apr 2008)</a></td>
</tr>
<tr class="field"><th class="field-name">Author:</th><td class="field-body">Daniel Stutzbach, Mike Verdone, Guido van Rossum</td>
</tr>
<tr class="field"><th class="field-name">Status:</th><td class="field-body">Accepted</td>
</tr>
<tr class="field"><th class="field-name">Type:</th><td class="field-body">Standards Track</td>
</tr>
<tr class="field"><th class="field-name">Content-Type:</th><td class="field-body"><a class="reference external" href="/dev/peps/pep-0012">text/x-rst</a></td>
</tr>
<tr class="field"><th class="field-name">Created:</th><td class="field-body">26-Feb-2007</td>
</tr>
<tr class="field"><th class="field-name">Python-Version:</th><td class="field-body">3.0</td>
</tr>
<tr class="field"><th class="field-name">Post-History:</th><td class="field-body">26-Feb-2007</td>
</tr>
</tbody>
</table>
<hr />
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#rationale-and-goals" id="id2">Rationale and Goals</a></li>
<li><a class="reference internal" href="#specification" id="id3">Specification</a></li>
<li><a class="reference internal" href="#raw-i-o" id="id4">Raw I/O</a></li>
<li><a class="reference internal" href="#buffered-i-o" id="id5">Buffered I/O</a><ul>
<li><a class="reference internal" href="#bufferedreader" id="id6"><tt class="docutils literal"><span class="pre">BufferedReader</span></tt></a></li>
<li><a class="reference internal" href="#bufferedwriter" id="id7"><tt class="docutils literal"><span class="pre">BufferedWriter</span></tt></a></li>
<li><a class="reference internal" href="#bufferedrwpair" id="id8"><tt class="docutils literal"><span class="pre">BufferedRWPair</span></tt></a></li>
<li><a class="reference internal" href="#bufferedrandom" id="id9"><tt class="docutils literal"><span class="pre">BufferedRandom</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#text-i-o" id="id10">Text I/O</a><ul>
<li><a class="reference internal" href="#unicode-encoding-decoding-issues" id="id11">Unicode encoding/decoding Issues</a></li>
</ul>
</li>
<li><a class="reference internal" href="#non-blocking-i-o" id="id12">Non-blocking I/O</a></li>
<li><a class="reference internal" href="#the-open-built-in-function" id="id13">The <tt class="docutils literal"><span class="pre">open()</span></tt> Built-in Function</a></li>
<li><a class="reference internal" href="#copyright" id="id14">Copyright</a></li>
</ul>
</div>
<div class="section" id="rationale-and-goals">
<h1><a class="toc-backref" href="#id2">Rationale and Goals</a></h1>
<p>Python allows for a variety of stream-like (a.k.a. file-like) objects
that can be used via <tt class="docutils literal"><span class="pre">read()</span></tt> and <tt class="docutils literal"><span class="pre">write()</span></tt> calls.  Anything that
provides <tt class="docutils literal"><span class="pre">read()</span></tt> and <tt class="docutils literal"><span class="pre">write()</span></tt> is stream-like.  However, more
exotic and extremely useful functions like <tt class="docutils literal"><span class="pre">readline()</span></tt> or
<tt class="docutils literal"><span class="pre">seek()</span></tt> may or may not be available on every stream-like object.
Python needs a specification for basic byte-based I/O streams to which
we can add buffering and text-handling features.</p>
<p>Once we have a defined raw byte-based I/O interface, we can add
buffering and text handling layers on top of any byte-based I/O class.
The same buffering and text handling logic can be used for files,
sockets, byte arrays, or custom I/O classes developed by Python
programmers.  Developing a standard definition of a stream lets us
separate stream-based operations like <tt class="docutils literal"><span class="pre">read()</span></tt> and <tt class="docutils literal"><span class="pre">write()</span></tt> from
implementation specific operations like <tt class="docutils literal"><span class="pre">fileno()</span></tt> and <tt class="docutils literal"><span class="pre">isatty()</span></tt>.
It encourages programmers to write code that uses streams as streams
and not require that all streams support file-specific or
socket-specific operations.</p>
<p>The new I/O spec is intended to be similar to the Java I/O libraries,
but generally less confusing.  Programmers who don't want to muck
about in the new I/O world can expect that the <tt class="docutils literal"><span class="pre">open()</span></tt> factory
method will produce an object backwards-compatible with old-style file
objects.</p>
</div>
<div class="section" id="specification">
<h1><a class="toc-backref" href="#id3">Specification</a></h1>
<p>The Python I/O Library will consist of three layers: a raw I/O layer,
a buffered I/O layer, and a text I/O layer.  Each layer is defined by
an abstract base class, which may have multiple implementations.  The
raw I/O and buffered I/O layers deal with units of bytes, while the
text I/O layer deals with units of characters.</p>
</div>
<div class="section" id="raw-i-o">
<h1><a class="toc-backref" href="#id4">Raw I/O</a></h1>
<p>The abstract base class for raw I/O is RawIOBase.  It has several
methods which are wrappers around the appropriate operating system
calls.  If one of these functions would not make sense on the object,
the implementation must raise an IOError exception.  For example, if a
file is opened read-only, the <tt class="docutils literal"><span class="pre">.write()</span></tt> method will raise an
<tt class="docutils literal"><span class="pre">IOError</span></tt>.  As another example, if the object represents a socket,
then <tt class="docutils literal"><span class="pre">.seek()</span></tt>, <tt class="docutils literal"><span class="pre">.tell()</span></tt>, and <tt class="docutils literal"><span class="pre">.truncate()</span></tt> will raise an
<tt class="docutils literal"><span class="pre">IOError</span></tt>.  Generally, a call to one of these functions maps to
exactly one operating system call.</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.read(n:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">bytes</span></tt></p>
<blockquote>
Read up to <tt class="docutils literal"><span class="pre">n</span></tt> bytes from the object and return them.  Fewer
than <tt class="docutils literal"><span class="pre">n</span></tt> bytes may be returned if the operating system call
returns fewer than <tt class="docutils literal"><span class="pre">n</span></tt> bytes.  If 0 bytes are returned, this
indicates end of file.  If the object is in non-blocking mode
and no bytes are available, the call returns <tt class="docutils literal"><span class="pre">None</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">.readinto(b:</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<blockquote>
Read up to <tt class="docutils literal"><span class="pre">len(b)</span></tt> bytes from the object and stores them in
<tt class="docutils literal"><span class="pre">b</span></tt>, returning the number of bytes read.  Like .read, fewer
than <tt class="docutils literal"><span class="pre">len(b)</span></tt> bytes may be read, and 0 indicates end of file.
<tt class="docutils literal"><span class="pre">None</span></tt> is returned if a non-blocking object has no bytes
available.  The length of <tt class="docutils literal"><span class="pre">b</span></tt> is never changed.</blockquote>
<p><tt class="docutils literal"><span class="pre">.write(b:</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<blockquote>
Returns number of bytes written, which may be <tt class="docutils literal"><span class="pre">&lt;</span> <span class="pre">len(b)</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">.seek(pos:</span> <span class="pre">int,</span> <span class="pre">whence:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.tell()</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.truncate(n:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.close()</span> <span class="pre">-&gt;</span> <span class="pre">None</span></tt></p>
</blockquote>
<p>Additionally, it defines a few other methods:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.readable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<blockquote>
Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the object was opened for reading,
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.  If <tt class="docutils literal"><span class="pre">False</span></tt>, <tt class="docutils literal"><span class="pre">.read()</span></tt> will raise an
<tt class="docutils literal"><span class="pre">IOError</span></tt> if called.</blockquote>
<p><tt class="docutils literal"><span class="pre">.writable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<blockquote>
Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the object was opened for writing,
<tt class="docutils literal"><span class="pre">False</span></tt> otherwise.  If <tt class="docutils literal"><span class="pre">False</span></tt>, <tt class="docutils literal"><span class="pre">.write()</span></tt> and
<tt class="docutils literal"><span class="pre">.truncate()</span></tt> will raise an <tt class="docutils literal"><span class="pre">IOError</span></tt> if called.</blockquote>
<p><tt class="docutils literal"><span class="pre">.seekable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<blockquote>
Returns <tt class="docutils literal"><span class="pre">True</span></tt> if the object supports random access (such as
disk files), or <tt class="docutils literal"><span class="pre">False</span></tt> if the object only supports
sequential access (such as sockets, pipes, and ttys).  If
<tt class="docutils literal"><span class="pre">False</span></tt>, <tt class="docutils literal"><span class="pre">.seek()</span></tt>, <tt class="docutils literal"><span class="pre">.tell()</span></tt>, and <tt class="docutils literal"><span class="pre">.truncate()</span></tt> will
raise an IOError if called.</blockquote>
<p><tt class="docutils literal"><span class="pre">.__enter__()</span> <span class="pre">-&gt;</span> <span class="pre">ContextManager</span></tt></p>
<blockquote>
Context management protocol.  Returns <tt class="docutils literal"><span class="pre">self</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">.__exit__(...)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></tt></p>
<blockquote>
Context management protocol.  Same as <tt class="docutils literal"><span class="pre">.close()</span></tt>.</blockquote>
</blockquote>
<p>If and only if a <tt class="docutils literal"><span class="pre">RawIOBase</span></tt> implementation operates on an
underlying file descriptor, it must additionally provide a
<tt class="docutils literal"><span class="pre">.fileno()</span></tt> member function.  This could be defined specifically by
the implementation, or a mix-in class could be used (need to decide
about this).</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.fileno()</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<blockquote>
Returns the underlying file descriptor (an integer)</blockquote>
</blockquote>
<p>Initially, three implementations will be provided that implement the
<tt class="docutils literal"><span class="pre">RawIOBase</span></tt> interface: <tt class="docutils literal"><span class="pre">FileIO</span></tt>, <tt class="docutils literal"><span class="pre">SocketIO</span></tt> (in the socket
module), and <tt class="docutils literal"><span class="pre">ByteIO</span></tt>.  Each implementation must determine whether
the object supports random access as the information provided by the
user may not be sufficient (consider <tt class="docutils literal"><span class="pre">open(&quot;/dev/tty&quot;,</span> <span class="pre">&quot;rw&quot;)</span></tt> or
<tt class="docutils literal"><span class="pre">open(&quot;/tmp/named-pipe&quot;,</span> <span class="pre">&quot;rw&quot;)</span></tt>).  As an example, <tt class="docutils literal"><span class="pre">FileIO</span></tt> can
determine this by calling the <tt class="docutils literal"><span class="pre">seek()</span></tt> system call; if it returns an
error, the object does not support random access.  Each implementation
may provided additional methods appropriate to its type.  The
<tt class="docutils literal"><span class="pre">ByteIO</span></tt> object is analogous to Python 2's <tt class="docutils literal"><span class="pre">cStringIO</span></tt> library,
but operating on the new bytes type instead of strings.</p>
</div>
<div class="section" id="buffered-i-o">
<h1><a class="toc-backref" href="#id5">Buffered I/O</a></h1>
<p>The next layer is the Buffered I/O layer which provides more efficient
access to file-like objects.  The abstract base class for all Buffered
I/O implementations is <tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt>, which provides similar methods
to RawIOBase:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.read(n:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">-1)</span> <span class="pre">-&gt;</span> <span class="pre">bytes</span></tt></p>
<blockquote>
Returns the next <tt class="docutils literal"><span class="pre">n</span></tt> bytes from the object.  It may return
fewer than <tt class="docutils literal"><span class="pre">n</span></tt> bytes if end-of-file is reached or the object is
non-blocking.  0 bytes indicates end-of-file.  This method may
make multiple calls to <tt class="docutils literal"><span class="pre">RawIOBase.read()</span></tt> to gather the bytes,
or may make no calls to <tt class="docutils literal"><span class="pre">RawIOBase.read()</span></tt> if all of the needed
bytes are already buffered.</blockquote>
<p><tt class="docutils literal"><span class="pre">.readinto(b:</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.write(b:</span> <span class="pre">bytes)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<blockquote>
Write <tt class="docutils literal"><span class="pre">b</span></tt> bytes to the buffer.  The bytes are not guaranteed to
be written to the Raw I/O object immediately; they may be
buffered.  Returns <tt class="docutils literal"><span class="pre">len(b)</span></tt>.</blockquote>
<p><tt class="docutils literal"><span class="pre">.seek(pos:</span> <span class="pre">int,</span> <span class="pre">whence:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.tell()</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.truncate(pos:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.flush()</span> <span class="pre">-&gt;</span> <span class="pre">None</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.close()</span> <span class="pre">-&gt;</span> <span class="pre">None</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.readable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.writable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.seekable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.__enter__()</span> <span class="pre">-&gt;</span> <span class="pre">ContextManager</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.__exit__(...)</span> <span class="pre">-&gt;</span> <span class="pre">None</span></tt></p>
</blockquote>
<p>Additionally, the abstract base class provides one member variable:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.raw</span></tt></p>
<blockquote>
A reference to the underlying <tt class="docutils literal"><span class="pre">RawIOBase</span></tt> object.</blockquote>
</blockquote>
<p>The <tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt> methods signatures are mostly identical to that
of <tt class="docutils literal"><span class="pre">RawIOBase</span></tt> (exceptions: <tt class="docutils literal"><span class="pre">write()</span></tt> returns <tt class="docutils literal"><span class="pre">None</span></tt>,
<tt class="docutils literal"><span class="pre">read()</span></tt>'s argument is optional), but may have different semantics.
In particular, <tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt> implementations may read more data
than requested or delay writing data using buffers.  For the most
part, this will be transparent to the user (unless, for example, they
open the same file through a different descriptor).  Also, raw reads
may return a short read without any particular reason; buffered reads
will only return a short read if EOF is reached; and raw writes may
return a short count (even when non-blocking I/O is not enabled!),
while buffered writes will raise <tt class="docutils literal"><span class="pre">IOError</span></tt> when not all bytes could
be written or buffered.</p>
<p>There are four implementations of the <tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt> abstract base
class, described below.</p>
<div class="section" id="bufferedreader">
<h2><a class="toc-backref" href="#id6"><tt class="docutils literal"><span class="pre">BufferedReader</span></tt></a></h2>
<p>The <tt class="docutils literal"><span class="pre">BufferedReader</span></tt> implementation is for sequential-access
read-only objects.  Its <tt class="docutils literal"><span class="pre">.flush()</span></tt> method is a no-op.</p>
</div>
<div class="section" id="bufferedwriter">
<h2><a class="toc-backref" href="#id7"><tt class="docutils literal"><span class="pre">BufferedWriter</span></tt></a></h2>
<p>The <tt class="docutils literal"><span class="pre">BufferedWriter</span></tt> implementation is for sequential-access
write-only objects.  Its <tt class="docutils literal"><span class="pre">.flush()</span></tt> method forces all cached data to
be written to the underlying RawIOBase object.</p>
</div>
<div class="section" id="bufferedrwpair">
<h2><a class="toc-backref" href="#id8"><tt class="docutils literal"><span class="pre">BufferedRWPair</span></tt></a></h2>
<p>The <tt class="docutils literal"><span class="pre">BufferedRWPair</span></tt> implementation is for sequential-access
read-write objects such as sockets and ttys.  As the read and write
streams of these objects are completely independent, it could be
implemented by simply incorporating a <tt class="docutils literal"><span class="pre">BufferedReader</span></tt> and
<tt class="docutils literal"><span class="pre">BufferedWriter</span></tt> instance.  It provides a <tt class="docutils literal"><span class="pre">.flush()</span></tt> method that
has the same semantics as a <tt class="docutils literal"><span class="pre">BufferedWriter</span></tt>'s <tt class="docutils literal"><span class="pre">.flush()</span></tt> method.</p>
</div>
<div class="section" id="bufferedrandom">
<h2><a class="toc-backref" href="#id9"><tt class="docutils literal"><span class="pre">BufferedRandom</span></tt></a></h2>
<p>The <tt class="docutils literal"><span class="pre">BufferedRandom</span></tt> implementation is for all random-access
objects, whether they are read-only, write-only, or read-write.
Compared to the previous classes that operate on sequential-access
objects, the <tt class="docutils literal"><span class="pre">BufferedRandom</span></tt> class must contend with the user
calling <tt class="docutils literal"><span class="pre">.seek()</span></tt> to reposition the stream.  Therefore, an instance
of <tt class="docutils literal"><span class="pre">BufferedRandom</span></tt> must keep track of both the logical and true
position within the object.  It provides a <tt class="docutils literal"><span class="pre">.flush()</span></tt> method that
forces all cached write data to be written to the underlying
<tt class="docutils literal"><span class="pre">RawIOBase</span></tt> object and all cached read data to be forgotten (so that
future reads are forced to go back to the disk).</p>
<p><em>Q: Do we want to mandate in the specification that switching between
reading and writing on a read-write object implies a .flush()?  Or is
that an implementation convenience that users should not rely on?</em></p>
<p>For a read-only <tt class="docutils literal"><span class="pre">BufferedRandom</span></tt> object, <tt class="docutils literal"><span class="pre">.writable()</span></tt> returns
<tt class="docutils literal"><span class="pre">False</span></tt> and the <tt class="docutils literal"><span class="pre">.write()</span></tt> and <tt class="docutils literal"><span class="pre">.truncate()</span></tt> methods throw
<tt class="docutils literal"><span class="pre">IOError</span></tt>.</p>
<p>For a write-only <tt class="docutils literal"><span class="pre">BufferedRandom</span></tt> object, <tt class="docutils literal"><span class="pre">.readable()</span></tt> returns
<tt class="docutils literal"><span class="pre">False</span></tt> and the <tt class="docutils literal"><span class="pre">.read()</span></tt> method throws <tt class="docutils literal"><span class="pre">IOError</span></tt>.</p>
</div>
</div>
<div class="section" id="text-i-o">
<h1><a class="toc-backref" href="#id10">Text I/O</a></h1>
<p>The text I/O layer provides functions to read and write strings from
streams.  Some new features include universal newlines and character
set encoding and decoding.  The Text I/O layer is defined by a
<tt class="docutils literal"><span class="pre">TextIOBase</span></tt> abstract base class.  It provides several methods that
are similar to the <tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt> methods, but operate on a
per-character basis instead of a per-byte basis.  These methods are:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.read(n:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">-1)</span> <span class="pre">-&gt;</span> <span class="pre">str</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.write(s:</span> <span class="pre">str)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.tell()</span> <span class="pre">-&gt;</span> <span class="pre">object</span></tt></p>
<blockquote>
Return a cookie describing the current file position.
The only supported use for the cookie is with .seek()
with whence set to 0 (i.e. absolute seek).</blockquote>
<p><tt class="docutils literal"><span class="pre">.seek(pos:</span> <span class="pre">object,</span> <span class="pre">whence:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">0)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<blockquote>
Seek to position <tt class="docutils literal"><span class="pre">pos</span></tt>.  If <tt class="docutils literal"><span class="pre">pos</span></tt> is non-zero, it must
be a cookie returned from <tt class="docutils literal"><span class="pre">.tell()</span></tt> and <tt class="docutils literal"><span class="pre">whence</span></tt> must be zero.</blockquote>
<p><tt class="docutils literal"><span class="pre">.truncate(pos:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">None)</span> <span class="pre">-&gt;</span> <span class="pre">int</span></tt></p>
<blockquote>
Like <tt class="docutils literal"><span class="pre">BufferedIOBase.truncate()</span></tt>, except that <tt class="docutils literal"><span class="pre">pos</span></tt> (if
not <tt class="docutils literal"><span class="pre">None</span></tt>) must be a cookie previously returned by <tt class="docutils literal"><span class="pre">.tell()</span></tt>.</blockquote>
</blockquote>
<p>Unlike with raw I/O, the units for .seek() are not specified - some
implementations (e.g. <tt class="docutils literal"><span class="pre">StringIO</span></tt>) use characters and others
(e.g. <tt class="docutils literal"><span class="pre">TextIOWrapper</span></tt>) use bytes.  The special case for zero is to
allow going to the start or end of a stream without a prior
<tt class="docutils literal"><span class="pre">.tell()</span></tt>.  An implementation could include stream encoder state in
the cookie returned from <tt class="docutils literal"><span class="pre">.tell()</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">TextIOBase</span></tt> implementations also provide several methods that are
pass-throughs to the underlaying <tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt> objects:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.flush()</span> <span class="pre">-&gt;</span> <span class="pre">None</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.close()</span> <span class="pre">-&gt;</span> <span class="pre">None</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.readable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.writable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
<p><tt class="docutils literal"><span class="pre">.seekable()</span> <span class="pre">-&gt;</span> <span class="pre">bool</span></tt></p>
</blockquote>
<p><tt class="docutils literal"><span class="pre">TextIOBase</span></tt> class implementations additionally provide the
following methods:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.readline()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></tt></p>
<blockquote>
Read until newline or EOF and return the line, or <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> if
EOF hit immediately.</blockquote>
<p><tt class="docutils literal"><span class="pre">.__iter__()</span> <span class="pre">-&gt;</span> <span class="pre">Iterator</span></tt></p>
<blockquote>
Returns an iterator that returns lines from the file (which
happens to be <tt class="docutils literal"><span class="pre">self</span></tt>).</blockquote>
<p><tt class="docutils literal"><span class="pre">.next()</span> <span class="pre">-&gt;</span> <span class="pre">str</span></tt></p>
<blockquote>
Same as <tt class="docutils literal"><span class="pre">readline()</span></tt> except raises <tt class="docutils literal"><span class="pre">StopIteration</span></tt> if EOF
hit immediately.</blockquote>
</blockquote>
<p>Two implementations will be provided by the Python library.  The
primary implementation, <tt class="docutils literal"><span class="pre">TextIOWrapper</span></tt>, wraps a Buffered I/O
object.  Each <tt class="docutils literal"><span class="pre">TextIOWrapper</span></tt> object has a property named
&quot;<tt class="docutils literal"><span class="pre">.buffer</span></tt>&quot; that provides a reference to the underlying
<tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt> object.  Its initializer has the following
signature:</p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">.__init__(self,</span> <span class="pre">buffer,</span> <span class="pre">encoding=None,</span> <span class="pre">errors=None,</span> <span class="pre">newline=None,</span> <span class="pre">line_buffering=False)</span></tt></p>
<blockquote>
<p><tt class="docutils literal"><span class="pre">buffer</span></tt> is a reference to the <tt class="docutils literal"><span class="pre">BufferedIOBase</span></tt> object to
be wrapped with the <tt class="docutils literal"><span class="pre">TextIOWrapper</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">encoding</span></tt> refers to an encoding to be used for translating
between the byte-representation and character-representation.
If it is <tt class="docutils literal"><span class="pre">None</span></tt>, then the system's locale setting will be
used as the default.</p>
<p><tt class="docutils literal"><span class="pre">errors</span></tt> is an optional string indicating error handling.
It may be set whenever <tt class="docutils literal"><span class="pre">encoding</span></tt> may be set.  It defaults
to <tt class="docutils literal"><span class="pre">'strict'</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">newline</span></tt> can be <tt class="docutils literal"><span class="pre">None</span></tt>, <tt class="docutils literal"><span class="pre">''</span></tt>, <tt class="docutils literal"><span class="pre">'\n'</span></tt>, <tt class="docutils literal"><span class="pre">'\r'</span></tt>, or
<tt class="docutils literal"><span class="pre">'\r\n'</span></tt>; all other values are illegal.  It controls the
handling of line endings.  It works as follows:</p>
<ul class="simple">
<li>On input, if <tt class="docutils literal"><span class="pre">newline</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>, universal newlines
mode is enabled.  Lines in the input can end in <tt class="docutils literal"><span class="pre">'\n'</span></tt>,
<tt class="docutils literal"><span class="pre">'\r'</span></tt>, or <tt class="docutils literal"><span class="pre">'\r\n'</span></tt>, and these are translated into
<tt class="docutils literal"><span class="pre">'\n'</span></tt> before being returned to the caller.  If it is
<tt class="docutils literal"><span class="pre">''</span></tt>, universal newline mode is enabled, but line endings
are returned to the caller untranslated.  If it has any of
the other legal values, input lines are only terminated by
the given string, and the line ending is returned to the
caller untranslated.  (In other words, translation to
<tt class="docutils literal"><span class="pre">'\n'</span></tt> only occurs if <tt class="docutils literal"><span class="pre">newline</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>.)</li>
<li>On output, if <tt class="docutils literal"><span class="pre">newline</span></tt> is <tt class="docutils literal"><span class="pre">None</span></tt>, any <tt class="docutils literal"><span class="pre">'\n'</span></tt>
characters written are translated to the system default
line separator, <tt class="docutils literal"><span class="pre">os.linesep</span></tt>.  If <tt class="docutils literal"><span class="pre">newline</span></tt> is <tt class="docutils literal"><span class="pre">''</span></tt>,
no translation takes place.  If <tt class="docutils literal"><span class="pre">newline</span></tt> is any of the
other legal values, any <tt class="docutils literal"><span class="pre">'\n'</span></tt> characters written are
translated to the given string.  (Note that the rules
guiding translation are different for output than for
input.)</li>
</ul>
<p><tt class="docutils literal"><span class="pre">line_buffering</span></tt>, if True, causes <tt class="docutils literal"><span class="pre">write()</span></tt> calls to imply
a <tt class="docutils literal"><span class="pre">flush()</span></tt> if the string written contains at least one
<tt class="docutils literal"><span class="pre">'\n'</span></tt> or <tt class="docutils literal"><span class="pre">'\r'</span></tt> character.  This is set by <tt class="docutils literal"><span class="pre">open()</span></tt>
when it detects that the underlying stream is a TTY device,
or when a <tt class="docutils literal"><span class="pre">buffering</span></tt> argument of <tt class="docutils literal"><span class="pre">1</span></tt> is passed.</p>
<p>Further notes on the <tt class="docutils literal"><span class="pre">newline</span></tt> parameter:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">'\r'</span></tt> support is still needed for some OSX applications
that produce files using <tt class="docutils literal"><span class="pre">'\r'</span></tt> line endings; Excel (when
exporting to text) and Adobe Illustrator EPS files are the
most common examples.</li>
<li>If translation is enabled, it happens regardless of which
method is called for reading or writing.  For example,
<tt class="docutils literal"><span class="pre">f.read()</span></tt> will always produce the same result as
<tt class="docutils literal"><span class="pre">''.join(f.readlines())</span></tt>.</li>
<li>If universal newlines without translation are requested on
input (i.e. <tt class="docutils literal"><span class="pre">newline=''</span></tt>), if a system read operation
returns a buffer ending in <tt class="docutils literal"><span class="pre">'\r'</span></tt>, another system read
operation is done to determine whether it is followed by
<tt class="docutils literal"><span class="pre">'\n'</span></tt> or not.  In universal newlines mode with
translation, the second system read operation may be
postponed until the next read request, and if the following
system read operation returns a buffer starting with
<tt class="docutils literal"><span class="pre">'\n'</span></tt>, that character is simply discarded.</li>
</ul>
</blockquote>
</blockquote>
<p>Another implementation, <tt class="docutils literal"><span class="pre">StringIO</span></tt>, creates a file-like <tt class="docutils literal"><span class="pre">TextIO</span></tt>
implementation without an underlying Buffered I/O object.  While
similar functionality could be provided by wrapping a <tt class="docutils literal"><span class="pre">BytesIO</span></tt>
object in a <tt class="docutils literal"><span class="pre">TextIOWrapper</span></tt>, the <tt class="docutils literal"><span class="pre">StringIO</span></tt> object allows for much
greater efficiency as it does not need to actually performing encoding
and decoding.  A String I/O object can just store the encoded string
as-is.  The <tt class="docutils literal"><span class="pre">StringIO</span></tt> object's <tt class="docutils literal"><span class="pre">__init__</span></tt> signature takes an
optional string specifying the initial value; the initial position is
always 0.  It does not support encodings or newline translations; you
always read back exactly the characters you wrote.</p>
<div class="section" id="unicode-encoding-decoding-issues">
<h2><a class="toc-backref" href="#id11">Unicode encoding/decoding Issues</a></h2>
<p>We should allow allow changing the encoding and error-handling
setting later.  The behavior of Text I/O operations in the face of
Unicode problems and ambiguities (e.g. diacritics, surrogates, invalid
bytes in an encoding) should be the same as that of the unicode
<tt class="docutils literal"><span class="pre">encode()</span></tt>/<tt class="docutils literal"><span class="pre">decode()</span></tt> methods.  <tt class="docutils literal"><span class="pre">UnicodeError</span></tt> may be raised.</p>
<p>Implementation note: we should be able to reuse much of the
infrastructure provided by the <tt class="docutils literal"><span class="pre">codecs</span></tt> module.  If it doesn't
provide the exact APIs we need, we should refactor it to avoid
reinventing the wheel.</p>
</div>
</div>
<div class="section" id="non-blocking-i-o">
<h1><a class="toc-backref" href="#id12">Non-blocking I/O</a></h1>
<p>Non-blocking I/O is fully supported on the Raw I/O level only.  If a
raw object is in non-blocking mode and an operation would block, then
<tt class="docutils literal"><span class="pre">.read()</span></tt> and <tt class="docutils literal"><span class="pre">.readinto()</span></tt> return <tt class="docutils literal"><span class="pre">None</span></tt>, while <tt class="docutils literal"><span class="pre">.write()</span></tt>
returns 0.  In order to put an object in non-blocking mode,
the user must extract the fileno and do it by hand.</p>
<p>At the Buffered I/O and Text I/O layers, if a read or write fails due
a non-blocking condition, they raise an <tt class="docutils literal"><span class="pre">IOError</span></tt> with <tt class="docutils literal"><span class="pre">errno</span></tt> set
to <tt class="docutils literal"><span class="pre">EAGAIN</span></tt>.</p>
<p>Originally, we considered propagating up the Raw I/O behavior, but
many corner cases and problems were raised.  To address these issues,
significant changes would need to have been made to the Buffered I/O
and Text I/O layers.  For example, what should <tt class="docutils literal"><span class="pre">.flush()</span></tt> do on a
Buffered non-blocking object?  How would the user instruct the object
to &quot;Write as much as you can from your buffer, but don't block&quot;?  A
non-blocking <tt class="docutils literal"><span class="pre">.flush()</span></tt> that doesn't necessarily flush all available
data is counter-intuitive.  Since non-blocking and blocking objects
would have such different semantics at these layers, it was agreed to
abandon efforts to combine them into a single type.</p>
</div>
<div class="section" id="the-open-built-in-function">
<h1><a class="toc-backref" href="#id13">The <tt class="docutils literal"><span class="pre">open()</span></tt> Built-in Function</a></h1>
<p>The <tt class="docutils literal"><span class="pre">open()</span></tt> built-in function is specified by the following
pseudo-code:</p>
<pre class="literal-block">
def open(filename, mode=&quot;r&quot;, buffering=None, *,
         encoding=None, errors=None, newline=None):
    assert isinstance(filename, (str, int))
    assert isinstance(mode, str)
    assert buffering is None or isinstance(buffering, int)
    assert encoding is None or isinstance(encoding, str)
    assert newline in (None, &quot;&quot;, &quot;\n&quot;, &quot;\r&quot;, &quot;\r\n&quot;)
    modes = set(mode)
    if modes - set(&quot;arwb+t&quot;) or len(mode) &gt; len(modes):
        raise ValueError(&quot;invalid mode: %r&quot; % mode)
    reading = &quot;r&quot; in modes
    writing = &quot;w&quot; in modes
    binary = &quot;b&quot; in modes
    appending = &quot;a&quot; in modes
    updating = &quot;+&quot; in modes
    text = &quot;t&quot; in modes or not binary
    if text and binary:
        raise ValueError(&quot;can't have text and binary mode at once&quot;)
    if reading + writing + appending &gt; 1:
        raise ValueError(&quot;can't have read/write/append mode at once&quot;)
    if not (reading or writing or appending):
        raise ValueError(&quot;must have exactly one of read/write/append mode&quot;)
    if binary and encoding is not None:
        raise ValueError(&quot;binary modes doesn't take an encoding arg&quot;)
    if binary and errors is not None:
        raise ValueError(&quot;binary modes doesn't take an errors arg&quot;)
    if binary and newline is not None:
        raise ValueError(&quot;binary modes doesn't take a newline arg&quot;)
    # XXX Need to spec the signature for FileIO()
    raw = FileIO(filename, mode)
    line_buffering = (buffering == 1 or buffering is None and raw.isatty())
    if line_buffering or buffering is None:
        buffering = 8*1024  # International standard buffer size
        # XXX Try setting it to fstat().st_blksize
    if buffering &lt; 0:
        raise ValueError(&quot;invalid buffering size&quot;)
    if buffering == 0:
        if binary:
            return raw
        raise ValueError(&quot;can't have unbuffered text I/O&quot;)
    if updating:
        buffer = BufferedRandom(raw, buffering)
    elif writing or appending:
        buffer = BufferedWriter(raw, buffering)
    else:
        assert reading
        buffer = BufferedReader(raw, buffering)
    if binary:
        return buffer
    assert text
    return TextIOWrapper(buffer, encoding, errors, newline, line_buffering)
</pre>
</div>
<div class="section" id="copyright">
<h1><a class="toc-backref" href="#id14">Copyright</a></h1>
<p>This document has been placed in the public domain.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
coding: utf-8
End: -->
</div>

</div>
<div class="footer">
<hr class="footer" />
<a class="reference external" href="pep-3116.txt">View document source</a>.
Generated on: 2013-09-17 06:14 UTC.
Generated by <a class="reference external" href="http://docutils.sourceforge.net/">Docutils</a> from <a class="reference external" href="http://docutils.sourceforge.net/rst.html">reStructuredText</a> source.

</div>
</body>
</html>
