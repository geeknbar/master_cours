<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
                      "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<!--
This HTML is auto-generated.  DO NOT EDIT THIS FILE!  If you are writing a new
PEP, see http://www.python.org/peps/pep-0001.html for instructions and links
to templates.  DO NOT USE THIS HTML FILE AS YOUR TEMPLATE!
-->
<head>
  <title>PEP 239 -- Adding a Rational Type to Python</title>
  <link rel="STYLESHEET" href="style.css" type="text/css" />
</head>
<body bgcolor="white">

<div class="header">
<table border="0">
  <tr><th>PEP:&nbsp;</th><td>239</td></tr>
  <tr><th>Title:&nbsp;</th><td>Adding a Rational Type to Python</td></tr>
  <tr><th>Version:&nbsp;</th><td>$Revision: 56105 $</td></tr>
  <tr><th>Last-Modified:&nbsp;</th><td><a href="http://svn.python.org/view/peps/trunk/pep-0239.txt">$Date: 2007-06-27 17:04:45 -0700 (Wed, 27 Jun 2007) $</a> </td></tr>
  <tr><th>Author:&nbsp;</th><td>Christopher A. Craig &lt;python-pep&#32;&#97;t&#32;ccraig.org&gt;, Moshe Zadka &lt;moshez&#32;&#97;t&#32;zadka.site.co.il&gt;</td></tr>
  <tr><th>Status:&nbsp;</th><td>Rejected</td></tr>
  <tr><th>Type:&nbsp;</th><td>Standards Track</td></tr>
  <tr><th>Created:&nbsp;</th><td>11-Mar-2001</td></tr>
  <tr><th>Python-Version:&nbsp;</th><td>2.2</td></tr>
  <tr><th>Post-History:&nbsp;</th><td>16-Mar-2001</td></tr>
</table>
</div>
<hr />
<div class="content">
<h3>Abstract</h3>
<pre>
    Python has no numeric type with the semantics of an unboundedly
    precise rational number.  This proposal explains the semantics of
    such a type, and suggests builtin functions and literals to
    support such a type.  This PEP suggests no literals for rational
    numbers; that is left for another PEP[1].

</pre>
<h3>BDFL Pronouncement</h3>
<pre>
    This PEP is rejected.  The needs outlined in the rationale section
    have been addressed to some extent by the acceptance of <a href="pep-0327.html">PEP 327</a>
    for decimal arithmetic.  Guido also noted, "Rational arithmetic
    was the default 'exact' arithmetic in ABC and it did not work out as
    expected".  See the python-dev discussion on 17 June 2005.

</pre>
<h3>Rationale</h3>
<pre>
    While sometimes slower and more memory intensive (in general,
    unboundedly so) rational arithmetic captures more closely the
    mathematical ideal of numbers, and tends to have behavior which is
    less surprising to newbies.  Though many Python implementations of
    rational numbers have been written, none of these exist in the
    core, or are documented in any way.  This has made them much less
    accessible to people who are less Python-savvy.


</pre>
<h3>RationalType</h3>
<pre>
    There will be a new numeric type added called RationalType.  Its
    unary operators will do the obvious thing.  Binary operators will
    coerce integers and long integers to rationals, and rationals to
    floats and complexes.

    The following attributes will be supported: .numerator and
    .denominator.  The language definition will promise that

        r.denominator * r == r.numerator

    that the GCD of the numerator and the denominator is 1 and that
    the denominator is positive.

    The method r.trim(max_denominator) will return the closest
    rational s to r such that abs(s.denominator) &lt;= max_denominator.


</pre>
<h3>The rational() Builtin</h3>
<pre>
    This function will have the signature rational(n, d=1).  n and d
    must both be integers, long integers or rationals.  A guarantee is
    made that

        rational(n, d) * d == n


</pre>
<h3>Open Issues</h3>
<pre>
    - Maybe the type should be called rat instead of rational.
      Somebody proposed that we have "abstract" pure mathematical
      types named complex, real, rational, integer, and "concrete"
      representation types with names like float, rat, long, int.

    - Should a rational number with an integer value be allowed as a
      sequence index?  For example, should s[5/3 - 2/3] be equivalent
      to s[1]?

    - Should shift and mask operators be allowed for rational numbers?
      For rational numbers with integer values?

    - Marcin 'Qrczak' Kowalczyk summarized the arguments for and
      against unifying ints with rationals nicely on c.l.py:

      Arguments for unifying ints with rationals:

      - Since 2 == 2/1 and maybe str(2/1) == '2', it reduces surprises
        where objects seem equal but behave differently.

      - / can be freely used for integer division when I *know* that
        there is no remainder (if I am wrong and there is a remainder,
        there will probably be some exception later).

      Arguments against:

      - When I use the result of / as a sequence index, it's usually
        an error which should not be hidden by making the program
        working for some data, since it will break for other data.

      - (this assumes that after unification int and rational would be
        different types:) Types should rarely depend on values. It's
        easier to reason when the type of a variable is known: I know
        how I can use it. I can determine that something is an int and
        expect that other objects used in this place will be ints too.

      - (this assumes the same type for them:) Int is a good type in
        itself, not to be mixed with rationals.  The fact that
        something is an integer should be expressible as a statement
        about its type. Many operations require ints and don't accept
        rationals. It's natural to think about them as about different
        types.


</pre>
<h3>References</h3>
<pre>
    [1] <a href="pep-0240.html">PEP 240</a>, Adding a Rational Literal to Python, Zadka,
        <a href="http://www.python.org/peps/pep-0240.html">http://www.python.org/peps/pep-0240.html</a>


</pre>
<h3>Copyright</h3>
<pre>
    This document has been placed in the public domain.


</pre>
</div>
</body>
</html>
